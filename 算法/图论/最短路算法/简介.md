# 最短路问题

**源点就是起点，汇点就是终点，n表示节点数，m表示边数**

![alt text](1833_db6dffa81d-37ff39642fd8f74476ddcd99944d1b4.png)




## 文字性复习

### Dijkstra-朴素O(n^2)

初始化距离数组:
- `dist[1] = 0`
- `dist[i] = inf`

进行n次循环，每次循环确定一个最小值加入S集合，n次之后得出所有的最短距离：
1. 将不在S中`dist_min`的点设为`t`
2. 将`t`加入S集合，并加入最短路集合
3. 用`t`更新到其他点的距离

### Dijkstra-堆优化O(mlogm)

利用邻接表和优先队列：
- 在`priority_queue<, greater<> > heap;`中将返回堆顶
- 利用堆顶来更新其他点，并加入堆中，类似宽搜

### Bellman_fordO(nm)

注意连锁想象需要备份:
- `struct Edge { int a, b, c; } Edge[M];`
- 初始化`dist`
- 松弛：`dist[x.b] = min(dist[x.b], backup[x.a] + x.w)`
- 进行k次松弛，每次访问m条边

### Spfa O(n)~O(nm)

利用队列优化，仅加入修改过的地方：
1. 进行k次循环
2. 利用宽搜模型去优化bellman_ford算法
3. 更新队列中当前点的所有出边

### Floyd O(n^3)

初始化`d`，然后利用`k, i, j`去更新`d`。


---

下面是根据算法在处理边权问题方面的通用性排序后的表格，其中能够处理负权边且能检测负权环的算法排在前面：

| 算法名称           | 适用场景                          | 时间复杂度             | 空间复杂度             | 处理负权边 | 检测负权环 |
| ------------------ | --------------------------------- | ---------------------- | ---------------------- | ---------- | ---------- |
| **Bellman-Ford**   | 单源最短路径（可处理负权边）      | O(VE)                  | O(V)                   | ✅         | ✅         |
| **SPFA**           | 单源最短路径（可处理负权边）      | 平均O(E)，最坏O(VE)    | O(V)                   | ✅         | ✅         |
| **Floyd-Warshall** | 计算所有节点对之间的最短路径      | O(n³)                  | O(n²)                  | ✅         | ❌         |
| **Dijkstra**       | 单源最短路径（无负权边）          | O((V + E) log V)       | O(V)                   | ❌         | ❌         |
| **A\***            | 启发式搜索，适用于有启发式信息的图 | 取决于启发式函数的质量 | O(V)                   | ❌         | ❌         |

**说明：**

- **Bellman-Ford** 和 **SPFA** 都能处理负权边，并能检测负权环，因此通用性最高，适用范围最广。  
- **Floyd-Warshall** 虽然能处理负权边，但不能正确处理包含负权环的情况，因此排在其后。  
- **Dijkstra** 与 **A\*** 算法仅适用于边权均为非负的场景，通用性较低。
  
## 关联记忆
