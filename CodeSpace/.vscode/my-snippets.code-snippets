{
    "0-1 Knapsack": {
        "prefix": "0-1 Knapsack",
        "body": [
            "// 0-1背包",
            "int zero_one_knapsack(int n, const vector<int>& w, const vector<int>& v, int V) {",
            "    /*",
            "    w : 物品的重量",
            "    v : 物品的价值",
            "    V : 背包容量",
            "    */",
            "    vector<int> dp(V + 1, 0); // dp[i] 表示容量为 i 时的最大价值",
            "    for (int i = 0; i < n; ++i) {",
            "        for (int j = V; j >= w[i]; --j) {",
            "            dp[j] = max(dp[j], dp[j - w[i]] + v[i]);",
            "        }",
            "    }",
            "    return dp[V]; // 返回最大价值",
            "}",
            ""
        ],
        "description": "Snippet for 0-1 Knapsack in cpp",
        "scope": "cpp"
    },
    "BFS in grids": {
        "prefix": "BFS in grids",
        "body": [
            "/*",
            "explanation:",
            "this is a template for BFS in grids.",
            "*/",
            "",
            "",
            ""
        ],
        "description": "Snippet for BFS in grids in cpp",
        "scope": "cpp"
    },
    "Binary search": {
        "prefix": "Binary search",
        "body": [
            "bool check(int x /*mid*/){",
            "\t",
            "\t//check the position of res in the right side of mid",
            "\t",
            "}",
            "",
            "int binary_search(int l/*left*/ ,int r/*right*/) {",
            "\tint mid ;",
            "\twhile(l < r)",
            "\t{",
            "\t\tmid = (l+r+1)>>1;",
            "\t\tif(check(mid))//res在mid或其右侧",
            "\t\t{",
            "\t\t\tl = mid;",
            "\t\t}",
            "\t\telse//res在不包括mid的左侧",
            "\t\t{",
            "\t\t\tr = mid -1;",
            "\t\t}",
            "\t}",
            "\t",
            "\t",
            "}"
        ],
        "description": "Snippet for Binary search in cpp",
        "scope": "cpp"
    },
    "C": {
        "prefix": "C",
        "body": [
            "int C(int n, int m) {",
            "    if (m == 0 || m == n) return 1;",
            "    m = min(m, n - m);",
            "    int result = 1;",
            "    for (int i = 1; i <= m; ++i) {",
            "        result = result * (n - i + 1) / i;",
            "    }",
            "    return result;",
            "}"
        ],
        "description": "Snippet for C in cpp",
        "scope": "cpp"
    },
    "Date iterator": {
        "prefix": "Date iterator",
        "body": [
            "/*",
            "2024-11-16日xx贺被蓝桥杯模拟赛的某道日期题目恶心坏了,",
            "于是连夜手搓了这个遍历日期的板子, (纯代码15行), 毕竟咱和python还是比不了",
            "更新:",
            "update on 2024/11/17",
            "封装成了类",
            "##### OS:",
            "我觉得罪魁祸首是每个月的天数不同, 真该死啊, 要是每个月都是30天就好了",
            "##### 代码功能:",
            "给定起始日期和结束日期, 能够遍历得到区间内每一天的日期",
            "*/",
            "",
            "class Date {",
            "public:",
            "    const int rq[13] = {29, 31, 28, 31, 30, 31, 30,31, 31, 30, 31, 30, 31};  // r[2]平年, rq[0] 是闰年",
            "    bool check(int yy) {",
            "        return ((yy % 4 == 0 && yy % 100 != 0) || (yy % 400 == 0));",
            "    }",
            "    int yy, mm, dd;",
            "    Date(int year, int month, int day) {  // 不带默认值的构造函数",
            "        yy = year, mm = month, dd = day;",
            "    }",
            "    void nextDay() {",
            "        if ((!check(yy) && dd == rq[mm]) || (check(yy) && mm == 2 ? dd == rq[0] : dd == rq[mm])) {",
            "            dd = 1, mm++;",
            "            if (mm > 12) mm = 1, yy++;",
            "        } else dd++;",
            "    }",
            "    bool isSame(Date d) {",
            "        return d.getDay() == dd && d.getMonth() == mm && d.getYear() == yy;",
            "    }",
            "    void print() const { printf(\"%d-%02d-%02d\\n\", yy, mm, dd); }",
            "    int getYear() const { return yy; }",
            "    int getMonth() const { return mm; }",
            "    int getDay() const { return dd; }",
            "};",
            "/*",
            "",
            "example :",
            "int main() {",
            "    int yy = 2023, mm = 12, dd = 1;   // 起始日期",
            "    int YY = 2024, MM = 12, DD = 31;  // 结束日期",
            "    Date start(yy, mm, dd);",
            "    Date end(YY, MM, DD);",
            "    while (true) {",
            "        start.print();",
            "        if (start.isSame(end)) break;",
            "        start.nextDay();",
            "    }",
            "    return 0;",
            "}",
            "*/"
        ],
        "description": "Snippet for Date iterator in cpp",
        "scope": "cpp"
    },
    "Dijkstra": {
        "prefix": "Dijkstra",
        "body": [
            ""
        ],
        "description": "Snippet for Dijkstra in cpp",
        "scope": "cpp"
    },
    "Dynamic pointer sequence table": {
        "prefix": "Dynamic pointer sequence table",
        "body": [
            "/*",
            "pointer sequence: |h1_p h2_p ··· hn_p|: the pointer sequence table",
            "",
            "                         ↓ptr",
            "",
            "relational table: | p_1 p_2 p_3 ... p_n |: the relation between elems to Bucket sequence table",
            "            ",
            "                       ↓index",
            "",
            "            data: | d_1 d_2 d_3... d_n  |",
            "*/",
            "",
            "const int N = 1e5+10;",
            "int h[N] ,e[N],ne[N],idx;"
        ],
        "description": "Snippet for Dynamic pointer sequence table in cpp",
        "scope": "cpp"
    },
    "Express IO": {
        "prefix": "Express IO",
        "body": [],
        "description": "Snippet for Express IO in cpp",
        "scope": "cpp"
    },
    "Group Knapsack": {
        "prefix": "Group Knapsack",
        "body": [
            "// 分组背包",
            "int group_knapsack(int n, const vector<vector<int>>& w, const vector<vector<int>>& v, int V) {",
            "    /*",
            "    w : 每组物品的重量",
            "    v : 每组物品的价值",
            "    V : 背包容量",
            "    */",
            "    vector<int> dp(V + 1, 0); // dp[i] 表示容量为 i 时的最大价值",
            "    for (int i = 0; i < n; ++i) {",
            "        vector<int> temp = dp; // 临时保存上一次的状态",
            "        for (int j = 0; j < w[i].size(); ++j) {",
            "            for (int k = V; k >= w[i][j]; --k) {",
            "                temp[k] = max(temp[k], dp[k - w[i][j]] + v[i][j]);",
            "            }",
            "        }",
            "        dp = temp; // 更新 dp 数组",
            "    }",
            "    return dp[V]; // 返回最大价值",
            "}",
            ""
        ],
        "description": "Snippet for Group Knapsack in cpp",
        "scope": "cpp"
    },
    "Header": {
        "prefix": "Header",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define fast ios ::sync_with_stdio(false), cin.tie(0), cout.tie(0)",
            "#define endl '\\n'",
            "using ll = long long;",
            "#define int long long",
            "#define OUT(v)                         \\",
            "    for (int k = 0; k < v.size(); ++k) \\",
            "        cout << v[k] << ' ';           \\",
            "    cout << endl;",
            "const int N = 1e5 + 10;",
            "int h[N], e[2 * N], ne[N];",
            "const int MOD = 1e9 + 7;",
            "int mul(int x, int y) {return 1LL * x * y % MOD; }",
            "int fact[N], ifact[N];"
        ],
        "description": "Snippet for Header in cpp",
        "scope": "cpp"
    },
    "High precision": {
        "prefix": "High precision",
        "body": [
            "// This code is used to implement high precision arithmetic.",
            "class HP {",
            "private:",
            "    string intPart, decPart;",
            "",
            "    void norm() {",
            "        if (decPart.empty() || all_of(decPart.begin(), decPart.end(), [](char c) { return c == '0'; }))",
            "            decPart.clear();",
            "    }",
            "",
            "public:",
            "    HP() : intPart(\"0\"), decPart(\"\") {}",
            "",
            "    HP(string val) {",
            "        size_t p = val.find('.');",
            "        if (p != string::npos) {",
            "            intPart = val.substr(0, p);",
            "            decPart = val.substr(p + 1);",
            "        } else {",
            "            intPart = val;",
            "            decPart.clear();",
            "        }",
            "        norm();",
            "    }",
            "",
            "    HP(int val) {",
            "        intPart = to_string(val);",
            "        decPart.clear();",
            "    }",
            "",
            "    HP(long long val) {",
            "        intPart = to_string(val);",
            "        decPart.clear();",
            "    }",
            "",
            "    HP(size_t val) {",
            "        intPart = to_string(val);",
            "        decPart.clear();",
            "    }",
            "",
            "    HP(double val) {",
            "        stringstream ss;",
            "        ss << val;",
            "        string s = ss.str();",
            "        size_t p = s.find('.');",
            "        if (p != string::npos) {",
            "            intPart = s.substr(0, p);",
            "            decPart = s.substr(p + 1);",
            "        } else {",
            "            intPart = s;",
            "            decPart.clear();",
            "        }",
            "        norm();",
            "    }",
            "",
            "    operator string() const {",
            "        return intPart + (decPart.empty() ? \"\" : \".\" + decPart);",
            "    }",
            "",
            "    operator double() const {",
            "        return stod(intPart) + (decPart.empty() ? 0.0 : stod(\"0.\" + decPart));",
            "    }",
            "",
            "    HP operator+(const HP& o) const {",
            "        string resInt = intPart, resDec = decPart;",
            "        int maxDec = max(decPart.size(), o.decPart.size());",
            "        if (decPart.size() < maxDec) resDec.append(maxDec - decPart.size(), '0');",
            "        if (o.decPart.size() < maxDec) resDec.append(maxDec - o.decPart.size(), '0');",
            "        ",
            "        int carry = 0, i = resDec.size() - 1;",
            "        while (i >= 0) {",
            "            int sum = resDec[i] - '0' + o.decPart[i] - '0' + carry;",
            "            carry = sum / 10;",
            "            resDec[i] = sum % 10 + '0';",
            "            --i;",
            "        }",
            "        return HP(resInt + \".\" + resDec);",
            "    }",
            "",
            "    HP operator+(int o) const {",
            "        return *this + HP(o);",
            "    }",
            "",
            "    HP operator+(long long o) const {",
            "        return *this + HP(o);",
            "    }",
            "",
            "    HP operator+(size_t o) const {",
            "        return *this + HP(o);",
            "    }",
            "",
            "    HP operator+(double o) const {",
            "        return *this + HP(o);",
            "    }",
            "",
            "    HP operator-(const HP& o) const {",
            "        string resInt = intPart, resDec = decPart;",
            "        int maxDec = max(decPart.size(), o.decPart.size());",
            "        if (decPart.size() < maxDec) resDec.append(maxDec - decPart.size(), '0');",
            "        if (o.decPart.size() < maxDec) resDec.append(maxDec - o.decPart.size(), '0');",
            "        ",
            "        int borrow = 0, i = resDec.size() - 1;",
            "        while (i >= 0) {",
            "            int diff = resDec[i] - '0' - o.decPart[i] + '0' - borrow;",
            "            if (diff < 0) { diff += 10; borrow = 1; } else borrow = 0;",
            "            resDec[i] = diff + '0';",
            "            --i;",
            "        }",
            "        return HP(resInt + \".\" + resDec);",
            "    }",
            "",
            "    HP operator-(int o) const {",
            "        return *this - HP(o);",
            "    }",
            "",
            "    HP operator-(long long o) const {",
            "        return *this - HP(o);",
            "    }",
            "",
            "    HP operator-(size_t o) const {",
            "        return *this - HP(o);",
            "    }",
            "",
            "    HP operator-(double o) const {",
            "        return *this - HP(o);",
            "    }",
            "",
            "    HP operator*(const HP& o) const {",
            "        string resInt = intPart + decPart, oInt = o.intPart + o.decPart;",
            "        vector<int> prod(resInt.size() + oInt.size(), 0);",
            "        ",
            "        for (int i = resInt.size() - 1; i >= 0; --i) ",
            "            for (int j = oInt.size() - 1; j >= 0; --j) {",
            "                int mul = (resInt[i] - '0') * (oInt[j] - '0');",
            "                prod[i + j + 1] += mul;",
            "            }",
            "        ",
            "        for (int i = prod.size() - 1; i > 0; --i) {",
            "            prod[i - 1] += prod[i] / 10;",
            "            prod[i] %= 10;",
            "        }",
            "        ",
            "        string result;",
            "        bool leadingZero = true;",
            "        for (int i = 0; i < prod.size(); ++i) {",
            "            if (leadingZero && prod[i] == 0) continue;",
            "            leadingZero = false;",
            "            result.push_back(prod[i] + '0');",
            "        }",
            "        ",
            "        int decLen = decPart.size() + o.decPart.size();",
            "        if (decLen > 0) result.insert(result.size() - decLen, \".\");",
            "        ",
            "        return HP(result);",
            "    }",
            "",
            "    HP operator*(int o) const {",
            "        return *this * HP(o);",
            "    }",
            "",
            "    HP operator*(long long o) const {",
            "        return *this * HP(o);",
            "    }",
            "",
            "    HP operator*(size_t o) const {",
            "        return *this * HP(o);",
            "    }",
            "",
            "    HP operator*(double o) const {",
            "        return *this * HP(o);",
            "    }",
            "",
            "    HP operator/(const HP& o) const {",
            "        if (o.intPart == \"0\" && o.decPart == \"0\") throw invalid_argument(\"0不能作除数\");",
            "        return *this;  ",
            "    }",
            "",
            "    HP operator/(int o) const {",
            "        return *this / HP(o);",
            "    }",
            "",
            "    HP operator/(long long o) const {",
            "        return *this / HP(o);",
            "    }",
            "",
            "    HP operator/(size_t o) const {",
            "        return *this / HP(o);",
            "    }",
            "",
            "    HP operator/(double o) const {",
            "        return *this / HP(o);",
            "    }",
            "",
            "",
            "    HP powIntPart(int exp) const {",
            "        if (exp < 0) throw invalid_argument(\"指数不能为负数\");",
            "        ",
            "",
            "        string result = \"1\";  ",
            "        string base = intPart;",
            "        while (exp > 0) {",
            "            if (exp % 2 == 1) { ",
            "                result = multiplyStrings(result, base);",
            "            }",
            "            base = multiplyStrings(base, base); ",
            "            exp /= 2; ",
            "        }",
            "        return HP(result);",
            "    }",
            "",
            "private:",
            " ",
            "    string multiplyStrings(const string& num1, const string& num2) const {",
            "        int len1 = num1.size(), len2 = num2.size();",
            "        vector<int> result(len1 + len2, 0);",
            "        ",
            "     ",
            "        for (int i = len1 - 1; i >= 0; --i) {",
            "            for (int j = len2 - 1; j >= 0; --j) {",
            "                int mul = (num1[i] - '0') * (num2[j] - '0');",
            "                int sum = mul + result[i + j + 1];",
            "                result[i + j + 1] = sum % 10;",
            "                result[i + j] += sum / 10;",
            "            }",
            "        }",
            "        ",
            "       ",
            "        string res;",
            "        for (int i = 0; i < result.size(); ++i) {",
            "            if (!(res.empty() && result[i] == 0)) {",
            "                res.push_back(result[i] + '0');",
            "            }",
            "        }",
            "        ",
            "        return res.empty() ? \"0\" : res;",
            "    }",
            "\tfriend istream& operator>>(istream& is, HP& h) {",
            "\t    string val;",
            "\t    is >> val; ",
            "",
            "\t    size_t p = val.find('.');",
            "\t    if (p != string::npos) {",
            "\t        h.intPart = val.substr(0, p); ",
            "\t        h.decPart = val.substr(p + 1);",
            "\t    } else {",
            "\t        h.intPart = val;",
            "\t        h.decPart.clear();",
            "\t    }",
            "\t    h.norm();",
            "\t",
            "\t    return is;",
            "\t}",
            "\t",
            "\tfriend ostream& operator<<(ostream& os, const HP& h) {",
            "\t    string str = h.intPart;  ",
            "\t",
            "\t    if (!h.decPart.empty()) {",
            "\t        str += \".\" + h.decPart;",
            "\t    }",
            "\t",
            "\t    if (os.flags() & ios::fixed) {",
            "\t        size_t dPos = str.find('.');",
            "\t        if (dPos != string::npos) {",
            "\t        ",
            "\t            while (str.back() == '0') str.pop_back();",
            "\t",
            "\t            if (str.back() == '.') str.pop_back();",
            "\t        }",
            "\t",
            "\t        if (os.precision() > 0) {",
            "\t            size_t reqDec = os.precision() - (str.size() - dPos - 1);",
            "\t            str.append(reqDec, '0');",
            "\t        }",
            "\t    }",
            "\t",
            "\t    os << str;",
            "\t    return os;",
            "\t}",
            "",
            "};",
            "",
            "",
            "",
            "vector <int>  add (vector <int> & A,vector<int> & B){",
            "\tint tem = 0 ;",
            "\tvector <int> res;",
            "\tif(A.size()>B.size())return add(B,A);",
            "\tfor(int i =0 ; i <B.size();i++){",
            "\t\ttem += B[i];",
            "\t\tif(i<A.size()) tem+=A[i];",
            "\t\tres.push_back(tem%10);",
            "\t\ttem = tem/10; ",
            "\t}",
            "\tif(tem)res.push_back(tem);",
            "\treturn res;",
            "}",
            "//A>B",
            "vector<int> sub(vector<int>& A,vector<int > & B){",
            "\tint tem = 0;",
            "\tvector<int> res;",
            "\tfor(int i = 0; i < A.size();i++){",
            "\t\ttem =A[i] - tem;",
            "\t\tif(i< B.size()) tem = tem - B[i];",
            "\t\tres.push_back((10+tem)%10);",
            "\t\tif(tem<0)tem =1;",
            "\t\telse tem =0;",
            "\t}",
            "\twhile (res.size()>1 &&res.back() == 0)res.pop_back();",
            "\treturn res;",
            "}",
            "vector<int> mul (vector<int> & A ,int b){",
            "\tvector<int> res ;",
            "\tint tem = 0 ;",
            "\t for(int i =0 ;i <A.size()||tem;i++){",
            "\t \tif(i<A.size())tem += (A[i]*b);",
            "\t \tres.push_back(tem%10);",
            "\t\ttem /=10;",
            "\t }",
            "\treturn res;",
            "}",
            "vector<int> div(vector<int> A ,int b,int & mod){",
            "\tvector<int> res;",
            "\tmod= 0 ;",
            "\tfor(int i = A.size()-1;i>=0;i--){",
            "\t\tmod = 10*mod +A[i];",
            "\t\tres.push_back(mod/b);",
            "\t\tmod%=b;",
            "\t}",
            "\treverse(res.begin(),res.end());",
            "\twhile(res.size()>1&&res.back()==0)res.pop_back();",
            "\treturn res;",
            "}",
            "#include <iostream>",
            "using namespace std;",
            "",
            "/*",
            "example:",
            "    // 1. 创建与初始化测试",
            "    HP h1(\"123.456\"); // 字符串输入，带小数部分",
            "    HP h2(123);       // 整数输入",
            "    HP h3(123456789012345); // 长整型输入",
            "    HP h4(123.456);   // 双精度浮点数输入",
            "    ",
            "    cout << \"通过字符串 '123.456' 创建的 HP: \" << h1 << endl;",
            "    cout << \"通过整数 123 创建的 HP: \" << h2 << endl;",
            "    cout << \"通过长整型创建的 HP: \" << h3 << endl;",
            "    cout << \"通过双精度浮点数 123.456 创建的 HP: \" << h4 << endl;",
            "",
            "    // 2. 算术运算测试",
            "    HP h5 = h1 + h2;  // HP + int",
            "    cout << \"h1 + h2: \" << h5 << endl;",
            "",
            "    HP h6 = h1 - h2;  // HP - int",
            "    cout << \"h1 - h2: \" << h6 << endl;",
            "",
            "    HP h7 = h1 * h2;  // HP * int",
            "    cout << \"h1 * h2: \" << h7 << endl;",
            "",
            "    HP h8 = h1 / h2;  // HP / int",
            "    cout << \"h1 / h2: \" << h8 << endl;",
            "",
            "    // 3. 整数部分的指数运算测试",
            "    HP h9 = h1.powIntPart(2);  // 整数部分的指数运算",
            "    cout << \"h1 ^ 2: \" << h9 << endl;",
            "",
            "    // 4. 输入输出流测试",
            "    HP h10;",
            "    cout << \"请输入一个数给 HP: \";",
            "    cin >> h10;  // 用户输入",
            "    cout << \"您输入的是: \" << h10 << endl;",
            "",
            "    // 5. 边界情况: 除以零",
            "    try {",
            "        HP h11(\"0\");",
            "        HP h12 = h1 / h11;  // 应该抛出异常",
            "    } catch (const invalid_argument& e) {",
            "        cout << \"捕获到异常: \" << e.what() << endl;",
            "    }",
            "",
            "/*",
            ""
        ],
        "description": "Snippet for High precision in cpp",
        "scope": "cpp"
    },
    "High speed IO": {
        "prefix": "High speed IO",
        "body": [
            "",
            "inline void fast_io() {",
            "    ios::sync_with_stdio(false);  ",
            "    cin.tie(0);  ",
            "}",
            "",
            "template <typename T>",
            "inline T read() {",
            "    T x = 0;",
            "    char c;",
            "    bool negative = false;",
            "    while ((c = getchar()) < '0' || c > '9') {",
            "        if (c == '-') {",
            "            negative = true;",
            "        }",
            "    }",
            "    do {",
            "        x = x * 10 + (c - '0');",
            "    } while ((c = getchar()) >= '0' && c <= '9');",
            "    return negative ? -x : x;",
            "}",
            "",
            "template <>",
            "inline double read<double>() {",
            "    double x = 0.0;",
            "    char c;",
            "    bool negative = false;",
            "    while ((c = getchar()) < '0' || c > '9') {",
            "        if (c == '-') {",
            "            negative = true;",
            "        }",
            "    }",
            "    do {",
            "        x = x * 10 + (c - '0');",
            "    } while ((c = getchar()) >= '0' && c <= '9');",
            "    if (c == '.') {",
            "        double frac = 1;",
            "        while ((c = getchar()) >= '0' && c <= '9') {",
            "            frac /= 10;",
            "            x += (c - '0') * frac;",
            "        }",
            "    }",
            "    return negative ? -x : x;",
            "}",
            "",
            "template <typename T>",
            "inline void write(const T &x) {",
            "    if constexpr (is_integral<T>::value) {",
            "        if (x < 0) {",
            "            putchar('-');",
            "            write(-x);",
            "        } else {",
            "            if (x >= 10) {",
            "                write(x / 10);",
            "            }",
            "            putchar(x % 10 + '0');",
            "        }",
            "    } else if constexpr (is_floating_point<T>::value) {",
            "        printf(\"%.6f\", x);",
            "    }",
            "}",
            "/*",
            "example:",
            "int main() {",
            "    fast_io(); ",
            "",
            "    int t = read<int>();  // 读取数据组数",
            "",
            "    while (t--) {",
            "        double a = read<double>(), b = read<double>();  // 每组输入两个浮点数",
            "        write(a + b);  // 输出结果",
            "        putchar('\\n');  // 换行",
            "    }",
            "*/"
        ],
        "description": "Snippet for High speed IO in cpp",
        "scope": "cpp"
    },
    "KMP": {
        "prefix": "KMP",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "/*",
            "    序列 中找 匹配序列",
            "*/",
            "#define sequence vector<char>",
            "#define dict vector<int> ",
            "sequence text;",
            "sequence pat;",
            "",
            "int kmp(sequence &text,sequence &pat){",
            "\tdict next(pat.size(),0);",
            "\tauto getNext = [&](){",
            "\t\tfor (int i = 1, j = 0; i < pat.size(); i++) {",
            "\t\t\twhile (j > 0 && pat[i] != pat[j]) j = next[j - 1];",
            "\t\t\tif (pat[i] == pat[j]) j++;",
            "\t\t\tnext[i] = j;",
            "\t\t}",
            "\t};",
            "\tgetNext();",
            "\tfor (int i = 0, j = 0; i < text.size(); i++) {",
            "\t\twhile (j > 0 && text[i] != pat[j]) j = next[j - 1];",
            "\t\tif (text[i] == pat[j]) j++;",
            "\t\tif (j == pat.size()) return i - pat.size() + 1;",
            "\t}",
            "\t",
            "}",
            "",
            "/*",
            "",
            "int main(){",
            "\tstring t;",
            "\tstring p;",
            "\tcin>>t>>p;",
            "\tfor(auto c:t) text.push_back(c);",
            "\tfor(auto c:p) pat.push_back(c);",
            "\tcout<<kmp(text,pat)<<endl;",
            "",
            "",
            "\treturn 0;",
            "}",
            "",
            "*/"
        ],
        "description": "Snippet for KMP in cpp",
        "scope": "cpp"
    },
    "multiCase": {
        "prefix": "multiCase",
        "body": [
            "int t;",
            "void solve(){",
            "",
            "}",
            "signed main() ",
            "{",
            "    cin>>t;",
            "    while(t--)",
            "    {",
            "        solve();",
            "    }",
            "    return 0;",
            "}"
        ],
        "description": "Snippet for multiCase in cpp",
        "scope": "cpp"
    },
    "Multiple Knapsack": {
        "prefix": "Multiple Knapsack",
        "body": [
            "// 多重背包",
            "int multiple_knapsack(int n, const vector<int>& w, const vector<int>& v, const vector<int>& c, int V) {",
            "    /*",
            "    w : 物品的重量",
            "    v : 物品的价值",
            "    c : 每种物品的最大数量",
            "    V : 背包容量",
            "    */",
            "    vector<int> dp(V + 1, 0); // dp[i] 表示容量为 i 时的最大价值",
            "    for (int i = 0; i < n; ++i) {",
            "        for (int k = 1; k <= c[i]; k <<= 1) { // 二进制拆分",
            "            int count = min(c[i] - (k - 1), V / (k * w[i]));",
            "            for (int j = V; j >= k * w[i]; --j) {",
            "                dp[j] = max(dp[j], dp[j - k * w[i]] + k * v[i]);",
            "            }",
            "        }",
            "    }",
            "    return dp[V]; // 返回最大价值",
            "}"
        ],
        "description": "Snippet for Multiple Knapsack in cpp",
        "scope": "cpp"
    },
    "Preprocessor head": {
        "prefix": "Preprocessor head",
        "body": [
            "#ifndef Preproccess",
            "#define Preproccess",
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "#define REP(a,b,c,d) for (a = b;a!=c;a+=d)",
            "#define FastIOS {ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);}",
            "#define i64 long long",
            "#define i32 int",
            "#define s64 size_t",
            "#define f32 float",
            "#define f64 double",
            "#define int long long",
            "#endif"
        ],
        "description": "Snippet for Preprocessor head in cpp",
        "scope": "cpp"
    },
    "pyMain": {
        "prefix": "pyMain",
        "body": [
            "# Visit my repo: https://github.com/Departag1an/-",
            "standard_input, packages, output_together = 1, 1, 0",
            "dfs, hashing, read_from_file = 0, 0, 0",
            "de = 1",
            "",
            "if 1:",
            "",
            "    if standard_input:",
            "        import io, os, sys",
            "        input = lambda: sys.stdin.readline().strip()",
            "",
            "        import math",
            "        inf = math.inf",
            "",
            "        def I():",
            "            return input()",
            "        ",
            "        def II():",
            "            return int(input())",
            "",
            "",
            "        def MII():",
            "            return map(int, input().split())",
            "",
            "        def LI():",
            "            return input().split()",
            "",
            "        def LII():",
            "            return list(map(int, input().split()))",
            "",
            "        def LFI():",
            "            return list(map(float, input().split()))",
            "",
            "        def GMI():",
            "            return map(lambda x: int(x) - 1, input().split())",
            "",
            "        def LGMI():",
            "            return list(map(lambda x: int(x) - 1, input().split()))",
            "",
            "    if packages:",
            "        from io import BytesIO, IOBase",
            "",
            "        import random",
            "        import os",
            "",
            "        import bisect",
            "        import typing",
            "        from collections import Counter, defaultdict, deque",
            "        from copy import deepcopy",
            "        from functools import cmp_to_key, lru_cache, reduce",
            "        from heapq import merge, heapify, heappop, heappush, heappushpop, nlargest, nsmallest",
            "        from itertools import accumulate, combinations, permutations, count, product",
            "        from operator import add, iand, ior, itemgetter, mul, xor",
            "        from string import ascii_lowercase, ascii_uppercase, ascii_letters",
            "        from typing import *",
            "        BUFSIZE = 4096",
            "",
            "    if output_together:",
            "        class FastIO(IOBase):",
            "            newlines = 0",
            "",
            "            def __init__(self, file):",
            "                self._fd = file.fileno()",
            "                self.buffer = BytesIO()",
            "                self.writable = \"x\" in file.mode or \"r\" not in file.mode",
            "                self.write = self.buffer.write if self.writable else None",
            "",
            "            def read(self):",
            "                while True:",
            "                    b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
            "                    if not b:",
            "                        break",
            "                    ptr = self.buffer.tell()",
            "                    self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
            "                self.newlines = 0",
            "                return self.buffer.read()",
            "",
            "            def readline(self):",
            "                while self.newlines == 0:",
            "                    b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
            "                    self.newlines = b.count(b\"\\n\") + (not b)",
            "                    ptr = self.buffer.tell()",
            "                    self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
            "                self.newlines -= 1",
            "                return self.buffer.readline()",
            "",
            "            def flush(self):",
            "                if self.writable:",
            "                    os.write(self._fd, self.buffer.getvalue())",
            "                    self.buffer.truncate(0), self.buffer.seek(0)",
            "",
            "        class IOWrapper(IOBase):",
            "            def __init__(self, file):",
            "                self.buffer = FastIO(file)",
            "                self.flush = self.buffer.flush",
            "                self.writable = self.buffer.writable",
            "                self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))",
            "                self.read = lambda: self.buffer.read().decode(\"ascii\")",
            "                self.readline = lambda: self.buffer.readline().decode(\"ascii\")",
            "",
            "        sys.stdout = IOWrapper(sys.stdout)",
            "",
            "    if dfs:",
            "        from types import GeneratorType",
            "",
            "        def bootstrap(f, stk=[]):",
            "            def wrappedfunc(*args, **kwargs):",
            "                if stk:",
            "                    return f(*args, **kwargs)",
            "                else:",
            "                    to = f(*args, **kwargs)",
            "                    while True:",
            "                        if type(to) is GeneratorType:",
            "                            stk.append(to)",
            "                            to = next(to)",
            "                        else:",
            "                            stk.pop()",
            "                            if not stk:",
            "                                break",
            "                            to = stk[-1].send(to)",
            "                    return to",
            "            return wrappedfunc",
            "",
            "    if hashing:",
            "        RANDOM = random.getrandbits(20)",
            "        class Wrapper(int):",
            "            def __init__(self, x):",
            "                int.__init__(x)",
            "",
            "            def __hash__(self):",
            "                return super(Wrapper, self).__hash__() ^ RANDOM",
            "",
            "    if read_from_file:",
            "        file = open(\"input.txt\", \"r\").readline().strip()[1:-1]",
            "        fin = open(file, 'r')",
            "        input = lambda: fin.readline().strip()",
            "        output_file = open(\"output.txt\", \"w\")",
            "        def fprint(*args, **kwargs):",
            "            print(*args, **kwargs, file=output_file)",
            "",
            "    if de:",
            "        def debug(*args, **kwargs):",
            "            print('\\033[92m', end='')",
            "            print(*args, **kwargs)",
            "            print('\\033[0m', end='')",
            "",
            "    fmax = lambda x, y: x if x > y else y",
            "    fmin = lambda x, y: x if x < y else y",
            "",
            "    class lst_lst:",
            "        def __init__(self, n) -> None:",
            "            self.n = n",
            "            self.pre = []",
            "            self.cur = []",
            "            self.lst = [-1] * n",
            "        ",
            "        def append(self, i, j):",
            "            self.pre.append(self.lst[i])",
            "            self.lst[i] = len(self.cur)",
            "            self.cur.append(j)",
            "        ",
            "        def iterate(self, i):",
            "            tmp = self.lst[i]",
            "            while tmp != -1:",
            "                yield self.cur[tmp]",
            "                tmp = self.pre[tmp]"
        ],
        "description": "Snippet for pyMain in python",
        "scope": "python"
    },
    "singleCase": {
        "prefix": "singleCase",
        "body": [
            "#include <iostream>",
            "int t;",
            "void solve(){",
            "",
            "}",
            "signed main() ",
            "{",
            "    cin>>t;",
            "    solve();",
            "    return 0;",
            "}"
        ],
        "description": "Snippet for singleCase in cpp",
        "scope": "cpp"
    },
    "Standard BFS": {
        "prefix": "Standard BFS",
        "body": [
            "/*",
            "    this is the standard BFS algorithm for solving the problem .",
            "    also is a simple model.",
            "*/",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "void bfs(const unordered_map<int ,vector<int>>& g ,int s,int e){",
            "    queue<int>que;",
            "    unordered_map<int ,bool> vis;",
            "    unordered_map<int,int> pre;   ",
            "    vis[s] =true;",
            "    que.push(s);",
            "    while (que.size()){",
            "        auto cur = que.front();",
            "        que.pop();",
            "        if(cur == e){",
            "            for (int i = e; i != s; i = pre[i]){",
            "                cout<<i<<\" \"; ",
            "            }",
            "            return;",
            "        }",
            "        for(auto nxt:g.at(cur)){",
            "            if(vis[nxt]) continue;",
            "            vis[nxt] = true;",
            "            pre[nxt] = cur;",
            "            que.push(nxt);",
            "        }",
            "",
            "    }",
            "    ",
            "}",
            "int main(){",
            "   unordered_map<int,vector<int>> g={",
            "        {1,{2,3}},",
            "        {2,{4,5}},",
            "        {3,{6,7}},",
            "   } ;",
            "   bfs(g,1,7);",
            "}"
        ],
        "description": "Snippet for Standard BFS in cpp",
        "scope": "cpp"
    },
    "test": {
        "prefix": "test",
        "body": [
            "#include <iostream>",
            "#include <vector>",
            "#include <ranges>",
            "#include <algorithm>",
            "#include <numeric>",
            "",
            "",
            "int main() {",
            "    // 初始化一个整数 vector",
            "    std::vector<int> vec = {1, 2, 3, 4, 5};",
            "",
            "    // 使用 ranges::transform 将每个元素乘以 2",
            "    auto doubled = vec | std::ranges::transform([](int n) { return n * 2; });",
            "",
            "    // 打印乘以 2 后的结果",
            "    std::cout << \"Doubled values: \";",
            "    for (int n : doubled) {",
            "        std::cout << n << \" \";",
            "    }",
            "    std::cout << std::endl;",
            "",
            "    // 使用 ranges::filter 筛选出大于 6 的元素",
            "    auto filtered = doubled | std::ranges::filter([](int n) { return n > 6; });",
            "",
            "    // 打印过滤后的结果",
            "    std::cout << \"Filtered values (greater than 6): \";",
            "    for (int n : filtered) {",
            "        std::cout << n << \" \";",
            "    }",
            "    std::cout << std::endl;",
            "",
            "    // 使用 ranges::sort 对原始 vector 进行排序",
            "    std::ranges::sort(vec);",
            "",
            "    std::cout << \"Sorted values: \";",
            "    for (int n : vec) {",
            "        std::cout << n << \" \";",
            "    }",
            "    std::cout << std::endl;",
            "",
            "    // 使用 ranges::reverse 对原始 vector 进行反转",
            "    std::ranges::reverse(vec);",
            "",
            "    std::cout << \"Reversed values: \";",
            "    for (int n : vec) {",
            "        std::cout << n << \" \";",
            "    }",
            "    std::cout << std::endl;",
            "",
            "    // 使用 ranges::accumulate 计算总和",
            "    int sum = std::ranges::accumulate(vec, 0);",
            "    std::cout << \"Sum of elements: \" << sum << std::endl;",
            "",
            "    // 使用 ranges::max_element 和 ranges::min_element 找到最大和最小元素",
            "    auto max_it = std::ranges::max_element(vec);",
            "    auto min_it = std::ranges::min_element(vec);",
            "",
            "    std::cout << \"Max element: \" << *max_it << \", Min element: \" << *min_it << std::endl;",
            "",
            "    // 使用 ranges::find 查找元素 3",
            "    auto find_it = std::ranges::find(vec, 3);",
            "    if (find_it != vec.end()) {",
            "        std::cout << \"Found element: \" << *find_it << std::endl;",
            "    }",
            "",
            "    // 使用 ranges::join 将多个范围连接在一起",
            "    std::vector<std::vector<int>> vec2d = {{1, 2}, {3, 4}, {5, 6}};",
            "    auto joined = vec2d | std::ranges::join;",
            "",
            "    std::cout << \"Joined values: \";",
            "    for (int n : joined) {",
            "        std::cout << n << \" \";",
            "    }",
            "    std::cout << std::endl;",
            "",
            "    // 使用 ranges::cartesian_product 计算两个范围的笛卡尔积",
            "    std::vector<int> a = {1, 2};",
            "    std::vector<int> b = {3, 4};",
            "    auto product = std::ranges::cartesian_product(a, b);",
            "",
            "    std::cout << \"Cartesian product: \";",
            "    for (auto [x, y] : product) {",
            "        std::cout << \"(\" << x << \", \" << y << \") \";",
            "    }",
            "    std::cout << std::endl;",
            "",
            "    // 使用 ranges::to 转换为容器",
            "    auto transformed = vec | std::ranges::transform([](int n) { return n * 2; })",
            "                            | std::ranges::to<std::vector<int>>();",
            "",
            "    std::cout << \"Transformed (to vector): \";",
            "    for (int n : transformed) {",
            "        std::cout << n << \" \";",
            "    }",
            "    std::cout << std::endl;",
            "",
            "    return 0;",
            "}"
        ],
        "description": "Snippet for test in cpp",
        "scope": "cpp"
    },
    "TEST": {
        "prefix": "TEST",
        "body": [
            "ccccc"
        ],
        "description": "Snippet from TEST",
        "scope": "py"
    },
    "Trie": {
        "prefix": "Trie",
        "body": [
            "int son[N][26], cnt[N], idx;",
            "",
            "void insert(char *str)",
            "{",
            "    int p = 0;",
            "    for (int i = 0; str[i]; i++)",
            "    {",
            "        int u = str[i] - 'a';",
            "        if (!son[p][u])",
            "            son[p][u] = ++idx;",
            "        p = son[p][u];",
            "    }",
            "    cnt[p]++; ",
            "}",
            "",
            "int query(char *str)",
            "{",
            "    int p = 0;",
            "    for (int i = 0; str[i]; i++)",
            "    {",
            "        int u = str[i] - 'a';",
            "        if (!son[p][u])",
            "            return 0;",
            "        p = son[p][u];",
            "    }",
            "    return cnt[p];",
            "}"
        ],
        "description": "Snippet for Trie in cpp",
        "scope": "cpp"
    },
    "Unbounded Knapsack": {
        "prefix": "Unbounded Knapsack",
        "body": [
            "//完全背包",
            "",
            "int complate_bp(int n,const vector<int> & w,const vector<int>&v, int V){",
            "    /*",
            "    w :weight",
            "    v :value",
            "    V :Capacity",
            "    */",
            "    vector<int> dp(V + 1, 0); // dp[i]表示容量为i时的最大价值",
            "    for (int i = 0; i < n; ++i) {",
            "        for (int j = w[i]; j <= V; ++j) {",
            "            dp[j] = max(dp[j], dp[j - w[i]] + v[i]);",
            "        }",
            "    }",
            "    return /*res */;",
            "}"
        ],
        "description": "Snippet for Unbounded Knapsack in cpp",
        "scope": "cpp"
    },
    "孙国庆的防检重标识": {
        "prefix": "孙国庆的防检重标识",
        "body": [
            "/*",
            "    Coded by: <SunGq>",
            "    团队Github: https://github.com/AliceAuto/AcEasy",
            "    Welcoming to join our team!",
            "*/",
            "/*",
            "     /\\_/\\  ",
            "    ( o.o ) ",
            "     > ^ <",
            "*/",
            "/*",
            "--------------------------------------------------------------------------------------------------------------------------------------------------------",
            "--------------------------------------------------------------------------------------------------------------------------------------------------------",
            "--------------------------------------------------------------------------------------------------------------------------------------------------------",
            "--------------------------------------------------------------------------------------------------------------------------------------------------------",
            "--------------------------------------------------------------------------------------------------------------------------------------------------------",
            "--------------------------------------------------------------------------------------------------------------------------------------------------------",
            "--------------------------------------------------------------------------------------------------------------------------------------------------------",
            "=-------------------------------------------------------------------------------------------------------------------------------------------------------",
            "-----------------------------------------------------------------------------------------------:--------------------------------------------------------",
            "--------------------------------------------------------------------------------------------------------------------------------------------------------",
            "--------------------------------------------------------------++*++++=+*++*+=---------------------------------------------------------------------------",
            "-----------------------------------------------------------+++-:::::::::==--=+++=-----------------------------------------------------------------------",
            "---------------------------------------------------------+*=:::::::::::::-+-----=++=--------------------------------------------------------------------",
            "------------------------------------------------------:=*=::::::::::::::::-+=-:::--++=-----------------=+=----------------------------------------------",
            "------------------------------------------------------+*-:::::::::::::::::::++-:::::=+=---------------=+*+----------------------------------------------",
            "-----------------------------------------------------+*-:::::::::::::::::::::+=::::::=+*+++==---------++++----------------------------------------------",
            "----------------------------------------------------=*=:::::::::::::::::::::::+=---:::=+++++++++==---=+++*+----------------------=====------------------",
            "----------------------------------------------------++::::::::::::::::::::::::-+-::--:-+=--+++==++*+==++=+++---------------======-----=++==-------------",
            "---------------------------------------------------=*-:::::::::::::::::::::::::=+---===++=---+*=====++++===**=----------=+=-:::---:::-::---+=-----------",
            "---------------------------------------------------++:::::::::::::::::::::-==++*++++++======+++*============+*+-------=+=-::--::::--:-:--::--=+---------",
            "---------------------------------------------------++:::::::::::::::::::::::-=++*+=====+=======+==============**=----==---::----:::-==+++++=--=+=-------",
            "---------------------------------------------------++:::::::::::::::::::::::=++--+===+*+=======================+**=-==:----:---::-+=::::::::::::==------",
            "---------------------------------------------------++::::::::::::---:::::++-:-:::-=+++==========++*++=====+++====+**+-::-:::--::=+:::::::::::::::-=-----",
            "---------------------------------------------------+*-:::::::::::=+-::-+=--::-::::-++==++=-=+===+--=+=-=+-::=+++===+*=:::::----==:::::::::::::::::==----",
            "----------------------------------------------------*-::::::::::::===+=-------:--:=+++-:::-:-**=+=-------:::-----++=+++-::::---+-::::::::::::::::::=----",
            "----------------------------------------------------++-:::::::::::-++---:----:-:-:-=-::---:::--+++---------:------:---=+=---::==::::::::::::::::::::+=--",
            "-----------------------------------------------------*+::::::::::-+=--+++=--:-:-::-:::::::::-:--------:--::::--:---::--=+=:-:-+-::::::::::::::::::::==--",
            "-----------------------------------------------------=*-::::::::=+=-:::::-:::::---::-::--:::-:-::::::--::-::----:--:-:-:=+-::=+-:::::::::::::::::::::+--",
            "------------------------------------------------------+*-::::::-+=-::-------:::::-::--::-::--:-::-::----::::-:-::::-::---==--==::::::::::::::::::::::=--",
            "-------------------------------------------------------++::::::==:::-:-:--:-:::--:---::::---:-:::+=--::::--:---:--::::-:--++-+-::::::::::::::::::::::==-",
            "--------------------------------------------------------+*-:::=+-:::---:-----:--:-----::-::---:-:-++-::::--:-::-:--:--::-:-=++-::::::::::::::::::::::-=-",
            "---------------------------------------------------------=*=::+=-::-:::--:-::-::-:--------::::-:::-=-::---------:::--:::::---=-::::::::::::::::::::::-+-",
            "-----------------------------------------------------------++=+-:::-------:--:-:-::::-::::---=-------::::---:---::--::::::----:::::::::::::::::::::::-+-",
            "------------------------------------------------------------=+=::-=+****+--:----::::::---=+*****+-----::::::-::-:::-:----:::--::::::::=::::::::::::::-+-",
            "-------------------------------------------------------------==::--+******=:---:----:::-+**##*****=-::::-::::-----:---:--:::--::::::++-::::::::::::::==-",
            "--------------------------------------=----------------------==--::-***##*+:-:---::-:--:=****##***+-:::::::::-:------:--:-----:::::=+::::::::::::::::=--",
            "-------------------------------------------------------------==--:::-*##*=-:::-:-:--:-::-******#*+:-::::---:::---:---:-::----=-==-::::::::::::::::::-+--",
            "--------------------------------------------+++=--------------+:-:::::::::-:----:-::--::::***##*:::-----:::--::-::-:-::-----=-::::::::::::::::::::::+=--",
            "-------------------------------------------=+===------------===--::::::::--==--------:::::::::::::-------::--::--::------::--::::::::::::::::::::::==---",
            "--------------------------------------------+===-----------+=-:-:::-::::::::::::::=---::::::::::::-:::-:::::--:::---::::::-=-:::::::::::::::::::::==----",
            "--------------------------------------------+++++=--------+-::::::-::::+*****+:::::::-::-===------::---------:::::------::-=-::::::::::::::::::::==-----",
            "--------------------------------------------===----------=+::::-:--::::+#*####+::::::-+=------:--::-:-----::--::::---:-::-=-:::::::::::::::::::-+=------",
            "-------------------==---------------------*++=------------+-----:--::::::===::::::::-=-:--------:::--::--:::-------------==:::::::::::::::::::=+--------",
            "--------------=+**+=---------------*+-----=++--------------+=--------:::::::::::::::-=::::--::--:--:-:-----:------------=+=++=::::::::::::-=+=----------",
            "---------=++**+*+--------------+=-=**=-----+=-------------+++++=--:------::::::::::::=--::------:-------:::----:::-:---+=----====++++++====-------------",
            "------=++++=---=*-------=---+++*+=*=**----=*-------------++++++++=----::--:::::::::::-==---::-::-:-::---::-:--::::-:-+=---------------------------------",
            "----------------*+=***+-+*+=**++**=-=*+::=*+------------=*+++++++++=--::---:::::::::--:---:::---:::----:-::--:--::==+-----------------------------------",
            "----------------++*+-+*-+*+-++--=----+*=**+-------------=*++++++++++++=-::--=::::==---::::--:-::-------:::------=+=-------------------------------------",
            "----------------*+**++==-+=----------=**+---------------+*+++++++***++++===++++++++++=------:--::----::::::--=+=----------------------------------------",
            "---------------=*+-=**-------------+****----------------=*++++++****++++*+++++++++++++++---:--:::-------==++--------------------------------------------",
            "---------------+*=--------------=**+=-**-----------------*++++++++++++++*+++++++++++++++---======++++==-------------------------------------------------",
            "----------==-=**---------------+*=----**-----------------=*++++++=-::-=++++++++++++++++=:::-+=----------------------------------------------------------",
            "------------==-------------=--=+=----+*=------------------+++++*=::::::=++++++++++++++=:-:-::*=---------------------------------------------------------",
            "------------------------=+=----=----=**--------------------=++=-:::::::=+++++++++++++=:::::-:=*---------------------------------------------------------",
            "----------=+=--------=*+=-==-------=**--------------------==:-=:::::::::+++++++++++=-::-:::-::++--------------------------------------------------------",
            "---------=+-=----=**+=-----+=----+**+---------------------+--=-::::::::::=+++++==+=--------:-:-*=-------------------------------------------------------",
            "----------=++++++=----------=+***+=----------------------=+::=-:::::::::::::::-=-==---:::-::::-++-------------------------------------------------------",
            "----------++=--------------------------------------------+=:-=-:::::::::::::::::-+=:--::-:--:-:=*-------------------------------------------------------",
            "---------------------------------------------------------=+--==::::::::::::::::::=+---:::::---:-*=------------------------------------------------------",
            "---------------------------------------------------------=+-:-=:::::::::::::::::::=--------:-::-+-==----------------------------------------------------",
            "----------------------------------------------------------+-:-==::::::::::::::::::-=-----:-:::::+-:-==--------------------------------------------------",
            "----------------------------------------------------------++-:-=-:::::::::::::::::-----:----:---=:---=+=------------------------------------------------",
            "-----------------------------------------------------------+=-:-=-:::::::::::::::-::::::::::::::-:-::--+=-----------------------------------------------",
            "------------------------------------------------------------+=:--=-::::::::::::::-::::::::::::::=--::---+=----------------------------------------------",
            "-------------------------------------------------------------+=-----:::::::::::::::::::::::::::::=:::---++----------------------------------------------",
            "--------------------------------------------------------------==::::-::::::::::::::::::::::::::::=::---:=+=---------------------------------------------",
            "----------------------------------------------------------------==-::-:::::::::::::::::::::::::=+-:::---=+=---------------------------------------------",
            "--------------------------------------------------------------------==+-:::::::::::::::--::--::=::--::--==----------------------------------------------",
            "------------------------------------------------------------------------=::::::::::::::::::::::=:-:::::-==----------------------------------------------",
            "--------------------------------------------------------------------------=-:::::::::::::::::::=--:-:--==-----------------------------------------------",
            "-----------------------------------------------------------------------------=::::::::::::::::=:-:::---=------------------------------------------------",
            "-------------------------------------------------------------------------------==-:::::::::::---:-----====+==-------------------------------------------",
            "----------------------------------------------------------------------------------====--:-----:-:----==++=----------------------------------------------",
            "----------------------------------------------------------------------------------------======++++=====-------------------------------------------------",
            "--------------------------------------------------------------------------------------------------------------------------------------------------------",
            "--------------------------------------------------------------------------------------------------------------------------------------------------------",
            "*/"
        ],
        "description": "Snippet for 孙国庆的防检重标识 in cpp",
        "scope": "cpp"
    },
    "手速练习": {
        "prefix": "手速练习",
        "body": [
            "",
            "",
            ""
        ],
        "description": "Snippet for 手速练习 in cpp",
        "scope": "cpp"
    },
    "板子": {
        "prefix": "板子",
        "body": [
            "#ifndef CODE_H",
            "#define CODE_H",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "",
            "",
            "#define I_ERROR 0x3f3f3f3f",
            "#define FastIOS {ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);}",
            "#define REP(a, b, c, d) for(int a = b; a != c; a += d)",
            "namespace Debug {",
            "    template<typename T>",
            "    void debug(const T& container) {",
            "        for (const auto& e : container) {",
            "            cout << e << \" \";",
            "        }",
            "        cout << endl;",
            "    }",
            "",
            "",
            "    template<typename K, typename V>",
            "    void debug(const std::map<K, V>& mp) {",
            "        for (const auto& e : mp) {",
            "            cout << e.first << \": \" << e.second << \" \";",
            "        }",
            "        cout << endl;",
            "    }",
            "",
            "    template<typename K, typename V>",
            "    void debug(const std::unordered_map<K, V>& umap) {",
            "        for (const auto& e : umap) {",
            "            cout << e.first << \": \" << e.second << \" \";",
            "        }",
            "        cout << endl;",
            "    }",
            "",
            "    template<typename T1, typename T2>",
            "    void debug(const std::pair<T1, T2>& p) {",
            "        cout << \"(\" << p.first << \", \" << p.second << \")\" << endl;",
            "    }",
            "",
            "",
            "    template<typename T1, typename T2, typename T3>",
            "    void debug(const std::tuple<T1, T2, T3>& t) {",
            "        cout << \"(\" << get<0>(t) << \", \" << get<1>(t) << \", \" << get<2>(t) << \")\" << endl;",
            "    }",
            "",
            "    template <typename T, typename N>",
            "    void debug(T* arr, N n) {",
            "        for (N i = 0; i < n; i++) {",
            "            cout << arr[i] << \" \";",
            "        }",
            "        cout << endl;",
            "    }",
            "}",
            "",
            "",
            "namespace IO {",
            "",
            "    std::vector<int> buildLPS(const std::string& pat) {",
            "        int m = pat.length();",
            "        std::vector<int> lps(m, 0);",
            "        int len = 0, i = 1;",
            "",
            "        while (i < m) {",
            "            if (pat[i] == pat[len]) {",
            "                len++;",
            "                lps[i] = len;",
            "                i++;",
            "            }",
            "            else {",
            "                if (len) {",
            "                    len = lps[len - 1];",
            "                }",
            "                else {",
            "                    i++;",
            "                }",
            "            }",
            "        }",
            "        return lps;",
            "    }",
            "",
            "    size_t kmpSearch(const std::string& text, const std::string& pat, size_t start) {",
            "        int n = text.length(), m = pat.length();",
            "        if (start >= n) return std::string::npos;",
            "",
            "        std::vector<int> lps = buildLPS(pat);",
            "        int i = start, j = 0;",
            "",
            "        while (i < n) {",
            "            if (text[i] == pat[j]) {",
            "                i++, j++;",
            "            }",
            "",
            "            if (j == m) {",
            "                return i - m;",
            "            }",
            "            else if (i < n && text[i] != pat[j]) {",
            "                if (j) {",
            "                    j = lps[j - 1];",
            "                }",
            "                else {",
            "                    i++;",
            "                }",
            "            }",
            "        }",
            "        return std::string::npos;",
            "    }",
            "",
            "    template <typename T>",
            "    T stringTo(const std::string& str);",
            "",
            "    template <>",
            "    int stringTo<int>(const std::string& str) {",
            "        return std::stoi(str);",
            "    }",
            "",
            "    template <>",
            "    float stringTo<float>(const std::string& str) {",
            "        return std::stof(str);",
            "    }",
            "",
            "    template <>",
            "    double stringTo<double>(const std::string& str) {",
            "        return std::stod(str);",
            "    }",
            "",
            "    template <>",
            "    std::string stringTo<std::string>(const std::string& str) {",
            "        return str;",
            "    }",
            "",
            "    template <typename T>",
            "    std::vector<T> split(const std::string& str, const std::string& delim = \" \") {",
            "        std::vector<T> res;",
            "        size_t start = 0, end = kmpSearch(str, delim, start);",
            "",
            "        while (end != std::string::npos) {",
            "            if (start != end) {",
            "                std::string token = str.substr(start, end - start);",
            "                res.push_back(stringTo<T>(token));",
            "            }",
            "            start = end + delim.length();",
            "            end = kmpSearch(str, delim, start);",
            "        }",
            "",
            "        if (start != str.length()) {",
            "            std::string token = str.substr(start);",
            "            res.push_back(stringTo<T>(token));",
            "        }",
            "",
            "        return res;",
            "    }",
            "",
            "    std::string input() {",
            "        std::string line;",
            "        std::getline(std::cin, line);",
            "        return line;",
            "    }",
            "}",
            "",
            "namespace OtherType {",
            "",
            "    class BigInt {",
            "    private:",
            "        std::string num;",
            "        bool neg;",
            "",
            "    public:",
            "        BigInt() : neg(false), num(\"0\") {}",
            "        BigInt(long long val) {",
            "            if (val < 0) { neg = true; val = -val; }",
            "            else neg = false;",
            "            num = std::to_string(val);",
            "        }",
            "        BigInt(const std::string& str) {",
            "            if (str[0] == '-') { neg = true; num = str.substr(1); }",
            "            else { neg = false; num = str; }",
            "        }",
            "",
            "        BigInt abs() const {",
            "            return BigInt(neg ? num.substr(1) : num);",
            "        }",
            "",
            "        void normalize() {",
            "            while (num.length() > 1 && num[0] == '0') num = num.substr(1);",
            "            if (num == \"0\") neg = false;",
            "        }",
            "",
            "        void print() const {",
            "            if (neg && num != \"0\") std::cout << \"-\";",
            "            std::cout << num;",
            "        }",
            "",
            "        BigInt operator+(const BigInt& other) const {",
            "            if (neg == other.neg) {",
            "                std::string res = add(num, other.num);",
            "                return BigInt(neg ? \"-\" + res : res);",
            "            }",
            "            else if (abs() >= other.abs()) {",
            "                std::string res = sub(num, other.num);",
            "                return BigInt(neg ? \"-\" + res : res);",
            "            }",
            "            else {",
            "                std::string res = sub(other.num, num);",
            "                return BigInt(other.neg ? \"-\" + res : res);",
            "            }",
            "        }",
            "",
            "        BigInt operator-(const BigInt& other) const {",
            "            if (neg == other.neg) {",
            "                if (abs() >= other.abs()) {",
            "                    std::string res = sub(num, other.num);",
            "                    return BigInt(neg ? \"-\" + res : res);",
            "                }",
            "                else {",
            "                    std::string res = sub(other.num, num);",
            "                    return BigInt(other.neg ? \"-\" + res : res);",
            "                }",
            "            }",
            "            else {",
            "                std::string res = add(num, other.num);",
            "                return BigInt(neg ? \"-\" + res : res);",
            "            }",
            "        }",
            "",
            "        BigInt operator*(const BigInt& other) const {",
            "            std::string res = mul(num, other.num);",
            "            bool result_neg = neg != other.neg;",
            "            return BigInt(result_neg ? \"-\" + res : res);",
            "        }",
            "",
            "        BigInt operator/(const BigInt& other) const {",
            "            if (other.num == \"0\") throw std::invalid_argument(\"Division by zero.\");",
            "            std::string res = div(num, other.num);",
            "            bool result_neg = neg != other.neg;",
            "            return BigInt(result_neg ? \"-\" + res : res);",
            "        }",
            "",
            "        bool operator>=(const BigInt& other) const {",
            "            if (neg && !other.neg) return false;",
            "            if (!neg && other.neg) return true;",
            "            if (neg && other.neg) return abs() <= other.abs();",
            "            return abs() >= other.abs();",
            "        }",
            "",
            "        bool operator==(const BigInt& other) const {",
            "            return neg == other.neg && num == other.num;",
            "        }",
            "",
            "        bool operator<(const BigInt& other) const {",
            "            if (neg != other.neg) return neg;",
            "            if (num.size() != other.num.size()) return num.size() < other.num.size();",
            "            return num < other.num;",
            "        }",
            "",
            "        bool operator<=(const BigInt& other) const {",
            "            return *this < other || *this == other;",
            "        }",
            "",
            "    private:",
            "        static std::string add(const std::string& a, const std::string& b) {",
            "            int carry = 0;",
            "            std::string res;",
            "            int i = a.size() - 1, j = b.size() - 1;",
            "            while (i >= 0 || j >= 0 || carry) {",
            "                int sum = carry;",
            "                if (i >= 0) sum += a[i--] - '0';",
            "                if (j >= 0) sum += b[j--] - '0';",
            "                carry = sum / 10;",
            "                res += (sum % 10) + '0';",
            "            }",
            "            std::reverse(res.begin(), res.end());",
            "            return res;",
            "        }",
            "",
            "        static std::string sub(const std::string& a, const std::string& b) {",
            "            int borrow = 0;",
            "            std::string res;",
            "            int i = a.size() - 1, j = b.size() - 1;",
            "            while (i >= 0 || j >= 0 || borrow) {",
            "                int diff = (a[i] - '0') - (j >= 0 ? b[j--] - '0' : 0) - borrow;",
            "                if (diff < 0) {",
            "                    diff += 10;",
            "                    borrow = 1;",
            "                }",
            "                else {",
            "                    borrow = 0;",
            "                }",
            "                res += diff + '0';",
            "                i--;",
            "            }",
            "            while (res.size() > 1 && res.back() == '0') {",
            "                res.pop_back();",
            "            }",
            "            std::reverse(res.begin(), res.end());",
            "            return res;",
            "        }",
            "",
            "        static std::string mul(const std::string& a, const std::string& b) {",
            "            int n = a.size(), m = b.size();",
            "            std::vector<int> res(n + m, 0);",
            "            for (int i = n - 1; i >= 0; --i) {",
            "                for (int j = m - 1; j >= 0; --j) {",
            "                    int mul = (a[i] - '0') * (b[j] - '0');",
            "                    int sum = mul + res[i + j + 1];",
            "                    res[i + j + 1] = sum % 10;",
            "                    res[i + j] += sum / 10;",
            "                }",
            "            }",
            "            std::string result;",
            "            for (int i : res) {",
            "                if (!(result.empty() && i == 0)) {",
            "                    result += i + '0';",
            "                }",
            "            }",
            "            return result.empty() ? \"0\" : result;",
            "        }",
            "",
            "        static std::string div(const std::string& a, const std::string& b) {",
            "            std::string result;",
            "            std::string temp = a.substr(0, b.size());",
            "            int n = a.size();",
            "            for (int i = b.size(); i <= n; ++i) {",
            "                int quotient = 0;",
            "                while (temp >= b) {",
            "                    temp = sub(temp, b);",
            "                    quotient++;",
            "                }",
            "                result += (quotient + '0');",
            "                if (i < n) temp += a[i];",
            "            }",
            "            return result;",
            "        }",
            "    };",
            "",
            "    template <typename T>",
            "    class Fraction {",
            "    private:",
            "        T num;",
            "        T denom;",
            "",
            "        T gcd(T a, T b) const {",
            "            while (b != T(0)) {",
            "                T temp = a;",
            "                a = b;",
            "                b = temp % b;",
            "            }",
            "            return a;",
            "        }",
            "",
            "        void simplify() {",
            "            if (denom == T(0)) throw std::invalid_argument(\"Denominator cannot be zero.\");",
            "            T gcd_value = gcd(num, denom);",
            "            num /= gcd_value;",
            "            denom /= gcd_value;",
            "            if (denom < T(0)) {",
            "                num = -num;",
            "                denom = -denom;",
            "            }",
            "        }",
            "",
            "    public:",
            "        Fraction(T n = 0, T d = 1) : num(n), denom(d) { simplify(); }",
            "",
            "        T getNum() const { return num; }",
            "        T getDenom() const { return denom; }",
            "",
            "        Fraction operator+(const Fraction& other) const {",
            "            T n = num * other.denom + denom * other.num;",
            "            T d = denom * other.denom;",
            "            return Fraction(n, d);",
            "        }",
            "",
            "        Fraction operator-(const Fraction& other) const {",
            "            T n = num * other.denom - denom * other.num;",
            "            T d = denom * other.denom;",
            "            return Fraction(n, d);",
            "        }",
            "",
            "        Fraction operator*(const Fraction& other) const {",
            "            T n = num * other.num;",
            "            T d = denom * other.denom;",
            "            return Fraction(n, d);",
            "        }",
            "",
            "        Fraction operator/(const Fraction& other) const {",
            "            if (other.num == T(0)) throw std::invalid_argument(\"Division by zero.\");",
            "            T n = num * other.denom;",
            "            T d = denom * other.num;",
            "            return Fraction(n, d);",
            "        }",
            "",
            "        void print() const {",
            "            std::cout << num << \"/\" << denom << std::endl;",
            "        }",
            "    };",
            "",
            "}",
            "",
            "#endif",
            "",
            "using namespace Debug;",
            "using namespace IO;",
            "using namespace OtherType;",
            "int n;",
            "vector<int> vec;",
            "",
            "void solve() {",
            "    ",
            "    debug(vec);",
            "}",
            "int main() {",
            "    FastIOS;",
            "    ",
            "    solve();",
            "    return 0;",
            "}"
        ],
        "description": "Snippet for 板子 in cpp",
        "scope": "cpp"
    }
}