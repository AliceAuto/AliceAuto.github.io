
## 特点

1. 不管什么图的存储方式都可以只需要能遍历所有边即可
2. 可以指定走最多多少条边
3. 可以处理负权回路(不如spfa一根)

## 例题

### [有边数限制的最短路](https://www.acwing.com/problem/content/855/)

#### 题目介绍

给定一个 n个点 m条边的有向图，图中可能存在重边和自环，**边权可能为负数。**
请你求出从 1号点到 n号点的最多经过k条边的最短距离，如果无法从1号到n号点，输出 impossible。

注意：图中可能**存在负权回路** 。

**输入格式**   
第一行包含三个整数n,m,k。  
接下来m行，每行包含三个整数x,y,z,表示存在一条从点x到y的有向边，边权为z。  
点的编号为1-n。

**输出格式**
输出一个整数，表示从1号点到n号点的最多更新k条边的最短距离。  
如果不存在满足条件的路径，输出impossible。


### 代码

```C++
#include<bits/stdc++.h>
using namespace std;

const int N=510,M=11000;
int dist[N],last[N];
int n,m,k;
struct 
{
    int a,b,w;
}edges[M];

void bellman_ford()
{
    memset(dist,0x3f,sizeof dist);
    dist[1]=0;
    for(int i=0;i<k;i++)
    {
        memcpy(last,dist,sizeof dist);
        for(int j=0;j<m;j++)
        {
            auto e=edges[j];
            //松弛操作
            dist[e.b]=min(dist[e.b],last[e.a]+e.w);
        }1
    }
     //三角不等式
     //dist[e.b]<=min(dist[e.b],last[e.a]+e.w);
}

int main()
{
    cin>>n>>m>>k;
    for(int i=0;i<m;i++)
    {
        int a,b,c;
        cin>>a>>b>>c;
        edges[i]={a,b,c};
    }
    bellman_ford();
    if(dist[n]>0x3f3f3f3f/2) cout<<"impossible"<<endl;
    else cout<<dist[n]<<endl;
    return 0;
}


```

### 分析

**bellman_ford算法在每一次遍历的时候，只允许更新一条边**
因此我们需要用last数组来存储上一次更新的边，  
每次更新一条边，如果一个点有多个出度边，在内循环中遍历所有边的时候，在这个点的所有出度边都会被更新。

**怎么判断是否有负权回路？**  
**在BF遍历n条边后dist[n]>0x3f3f3f3f/2的话 那么存在负权回路**

# 原理

---

## 🌟 **1. Bellman-Ford 算法允许路径重复走点**

在 **Bellman-Ford** 里，**路径** 是可以经过 **重复点** 的，这跟 **Dijkstra 算法** 不一样。  
但为什么没事？主要有这两种情况：

---

### 📌 **正权边情况下**
- **如果所有边权值都是正的**，就算路径可以重复经过同一个点，但实际上**不会这么做**，因为：
  - 你再绕回一个点，路径长度一定会增加。
  - 不绕回来肯定更短，算法会自然“避免”走重复点。
- 所以在正权图里，虽然 Bellman-Ford 可以走重复点，但**不会主动这么干**，最短路径都不会走回头路。

#### ➡ **图理解**  
```text
1 → 2 → 3 → 4  
路径走 1 → 2 → 3 → 4，距离越来越大  
你回头绕回来干啥？多花代价，不划算！
```

---

### 📌 **负权边情况下**
- 如果边权有负值，你**走重复点也可能让路径更短**。  
- 举个形象点的说法：
  - 本来从 A 到 B 要花 10  
  - 如果你绕一下经过一个 “负环”，比如来回走几次，每次减少 5  
  - 你原来的路径就能不断变短  
- **负权环**可以让路径**无限减少**，导致重复走点（特别是走环）成为一种“优化”手段。

---

## 🌟 **2. 为什么正权边不会“走回头路”？**

### ➡ **直观解释**
> 正权边意味着“代价”是越来越高的  
> 你走过一次后，`dist` 已经是最短  
> 你绕回来还得花钱，肯定不会比上次便宜  
> 👉 没必要再走！

### ➡ **数学解释**
- 每次松弛 `dist[b] = min(dist[b], dist[a] + w)`  
- 正权值保证 `dist[a] + w` 不会比已经存在的 `dist[b]` 更小  
- 所以不会再更新 `dist[b]`  
  → 没有新的路径，就不会重复走

---

## 🌟 **3. 为什么负权值会“走重复点”**
- 如果 `w < 0`  
- 每次松弛就可能：
  ```cpp
  dist[b] = min(dist[b], dist[a] + w)
  ```
- 一次绕回来，路径就变小  
- 再绕回来，还能变小  
- 这样就会形成“走重复点”的路径，尤其是**负环**

---

## 🌟 **4. 经典例子（负权回路）**
```text
1 → 2 (1)
2 → 3 (1)
3 → 2 (-3)
```

走：
```
1 → 2 → 3 → 2 → 3 → 2 → 3 ...
```
- 你每次走 `2 → 3 → 2`，都会少 2
- 路径长度无限减少  
  → `dist` 会一直被松弛

---

## 🌟 **5. Bellman-Ford 的特点总结**
| Bellman-Ford                    | Dijkstra                   |
|---------------------------------|----------------------------|
| 允许路径重复点                 | 不允许（走过的点就不更新） |
| 能处理负权（不能负环）         | 不能处理负权              |
| 通过 `n-1` 次松弛，检验最短路径 | 用优先队列每次贪心找最近  |
| 可检测负权环                   | 不能检测负权环            |

---

## 🌟 **6. 理解**
> Bellman-Ford 的路径是**可以**重复经过点的，  
但如果**全是正权边**，自然**不会再走回头路**（没有必要）。

---
### ✅ 表述（加一句扩展）  
> 因为权值是正的，Bellman-Ford 自然不会经过已经走过的点（路径不会继续被松弛）。  
> 只有负权边（特别是负权环）情况下，路径才会继续走回头路，甚至无限循环。

---
