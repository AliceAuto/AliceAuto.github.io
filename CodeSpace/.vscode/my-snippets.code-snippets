{
    "0-1 Knapsack": {
        "prefix": "0-1 Knapsack",
        "body": [
            "// 0-1背包",
            "int zero_one_knapsack(int n, const vector<int>& w, const vector<int>& v, int V) {",
            "    /*",
            "    w : 物品的重量",
            "    v : 物品的价值",
            "    V : 背包容量",
            "    */",
            "    vector<int> dp(V + 1, 0); // dp[i] 表示容量为 i 时的最大价值",
            "    for (int i = 0; i < n; ++i) {",
            "        for (int j = V; j >= w[i]; --j) {",
            "            dp[j] = max(dp[j], dp[j - w[i]] + v[i]);",
            "        }",
            "    }",
            "    return dp[V]; // 返回最大价值",
            "}"
        ],
        "description": "Snippet from 0-1 Knapsack",
        "scope": "cpp"
    },
    "A star": {
        "prefix": "A star",
        "body": [
            "#include <iostream>",
            "#include <vector>",
            "#include <queue>",
            "#include <cmath>",
            "#include <cstring> // 用于 memset",
            "#include <functional> // 用于自定义函数",
            "#include <utility> // 用于 pair",
            "",
            "using namespace std;",
            "",
            "const int MAXN = 510;   // 根据题目需求调整最大网格大小",
            "const int INF = 0x3f3f3f3f;",
            "",
            "// 定义方向数组（上下左右）",
            "int dx[] = {-1, 1, 0, 0};",
            "int dy[] = {0, 0, -1, 1};",
            "",
            "// 节点结构体",
            "struct Node {",
            "    int x, y;        // 节点的坐标",
            "    int g, h;        // g 为起点到当前点的代价，h 为启发式估计",
            "    int f() const { return g + h; } // 总代价 f = g + h",
            "",
            "    // 优先队列需要的比较运算符，按 f 值升序排列",
            "    bool operator<(const Node& other) const {",
            "        return f() > other.f(); // 小根堆",
            "    }",
            "};",
            "",
            "// 判断坐标是否在网格范围内",
            "inline bool isValid(int x, int y, int n, int m) {",
            "    return x >= 0 && x < n && y >= 0 && y < m;",
            "}",
            "",
            "// A* 主函数",
            "int a_star(int n, int m, vector<vector<int>>& grid, pair<int, int> start, pair<int, int> end, function<int(int, int)> heuristic) {",
            "    priority_queue<Node> pq; // 小根堆",
            "    vector<vector<int>> dist(n, vector<int>(m, INF)); // 距离表",
            "",
            "    // 起点初始化",
            "    int sx = start.first, sy = start.second;",
            "    int ex = end.first, ey = end.second;",
            "    pq.push({sx, sy, 0, heuristic(sx, sy)});",
            "    dist[sx][sy] = 0;",
            "",
            "    // 主循环",
            "    while (!pq.empty()) {",
            "        Node cur = pq.top(); pq.pop();",
            "        int x = cur.x, y = cur.y;",
            "",
            "        // 如果到达终点",
            "        if (x == ex && y == ey) return cur.g;",
            "",
            "        // 扩展邻居节点",
            "        for (int i = 0; i < 4; i++) {",
            "            int nx = x + dx[i], ny = y + dy[i];",
            "            if (!isValid(nx, ny, n, m) || grid[nx][ny] == 1) continue; // 不合法或障碍物",
            "",
            "            int new_g = cur.g + 1; // 假设每次移动的代价为 1",
            "            if (new_g < dist[nx][ny]) {",
            "                dist[nx][ny] = new_g;",
            "                pq.push({nx, ny, new_g, heuristic(nx, ny)});",
            "            }",
            "        }",
            "    }",
            "",
            "    return -1; // 无法到达终点",
            "}",
            "",
            "int main() {",
            "    // 输入网格大小",
            "    int n, m;",
            "    cin >> n >> m;",
            "",
            "    // 输入网格（0 为可走，1 为障碍物）",
            "    vector<vector<int>> grid(n, vector<int>(m));",
            "    for (int i = 0; i < n; i++) {",
            "        for (int j = 0; j < m; j++) {",
            "            cin >> grid[i][j];",
            "        }",
            "    }",
            "",
            "    // 起点和终点坐标",
            "    int sx, sy, ex, ey;",
            "    cin >> sx >> sy >> ex >> ey;",
            "",
            "    // 启发式函数（曼哈顿距离）",
            "    auto heuristic = [&](int x, int y) {",
            "        return abs(x - ex) + abs(y - ey);",
            "    };",
            "",
            "    // 调用 A* 算法",
            "    int result = a_star(n, m, grid, {sx, sy}, {ex, ey}, heuristic);",
            "",
            "    if (result == -1) cout << \"impossible\" << endl;",
            "    else cout << result << endl;",
            "",
            "    return 0;",
            "}"
        ],
        "description": "Snippet from A star",
        "scope": "cpp"
    },
    "Bellman Ford": {
        "prefix": "Bellman Ford",
        "body": [
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "",
            "const int N=510,M=11000;",
            "int dist[N],last[N];",
            "int n,m,k;",
            "struct ",
            "{",
            "    int a,b,w;",
            "}edges[M];",
            "",
            "void bellman_ford()",
            "{",
            "    memset(dist,0x3f,sizeof dist);",
            "    dist[1]=0;",
            "    for(int i=0;i<k;i++)",
            "    {",
            "        memcpy(last,dist,sizeof dist);",
            "        for(int j=0;j<m;j++)",
            "        {",
            "            auto e=edges[j];",
            "            //松弛操作",
            "            dist[e.b]=min(dist[e.b],last[e.a]+e.w);",
            "        }",
            "    }",
            "     //三角不等式",
            "     //dist[e.b]<=min(dist[e.b],last[e.a]+e.w);",
            "}",
            "",
            "int main()",
            "{",
            "    cin>>n>>m>>k;",
            "    for(int i=0;i<m;i++)",
            "    {",
            "        int a,b,c;",
            "        cin>>a>>b>>c;",
            "        edges[i]={a,b,c};",
            "    }",
            "    bellman_ford();",
            "    if(dist[n]>0x3f3f3f3f/2) cout<<\"impossible\"<<endl;",
            "    else cout<<dist[n]<<endl;",
            "    return 0;",
            "}",
            ""
        ],
        "description": "Snippet from Bellman Ford",
        "scope": "cpp"
    },
    "BFS 1": {
        "prefix": "BFS 1",
        "body": [
            "#define all(x) x.begin(),x.end()",
            "#define x first",
            "#define y second",
            "",
            "",
            "void bfs(const vector<vector<int>>& g,pair<int,int> s,pair<int,int> e){",
            "    int n = g.size();",
            "    int m = g[0].size();",
            "    ",
            "    auto checker = [&] (pair<int,int> p){",
            "        if(p.x<0||p.x>=n||p.y<0||p.y>=m)return false;",
            "        else return true;",
            "    };",
            "    vector<vector<bool>>vis(n,vector<bool>(m,0));",
            "    vector<vector<pair<int,int>>>pre(n,vector<pair<int,int>>(m,{-1,-1}));",
            "    queue<pair<int,int>>q;",
            "    q.push(s);",
            "    vis[s.x][s.y] = 1;",
            "    vector<int>dx = {1,0,-1,0};",
            "    vector<int>dy = {0,1,0,-1};",
            "    ",
            "    while(!q.empty()){",
            "        auto p = q.front();",
            "        q.pop();",
            "        if(p==e){",
            "            vector<pair<int,int>>path;",
            "            while(p!=s){",
            "                path.push_back(p);",
            "                p = pre[p.x][p.y];",
            "            }",
            "            path.push_back(s);",
            "            reverse(all(path));",
            "            for(auto p:path){",
            "                cout<<p.x<<\" \"<<p.y<<endl;",
            "            }",
            "            return;",
            "        } ",
            "        for(int i = 0;i<4;i++){",
            "            auto np = make_pair(p.x+dx[i],p.y+dy[i]);",
            "            if(checker(np)&&!vis[np.x][np.y]&&!g[np.x][np.y]){",
            "                q.push(np);",
            "                vis[np.x][np.y] = 1;",
            "                pre[np.x][np.y] = p;",
            "            } ",
            "        }",
            "    }",
            "",
            "}"
        ],
        "description": "Snippet from BFS 1",
        "scope": "cpp"
    },
    "BFS 2": {
        "prefix": "BFS 2",
        "body": [
            "const int N  = 1e5;",
            "int e[N],ne[N],h[N],pre[N],idx;",
            "int n ;",
            "void init (){",
            "    memset(h,-1,sizeof h);",
            "}",
            "void add(int a,int b){",
            "    e[idx] = b;",
            "    ne[idx] = h[a];",
            "    h[a] = idx++; ",
            "}",
            "void BFS(){",
            "    queue<int> q;",
            "    q.push(1);",
            "    bitset<N> st;",
            "    st[1] = true;",
            "    memset(pre, -1, sizeof pre);  ",
            "    pre[1] = -1; ",
            "    while (q.size())",
            "    {",
            "        auto f = q.front();",
            "        q.pop(); ",
            "",
            "        if(f == n){",
            "            vector<int> path;",
            "            for(int cur = n; cur != -1; cur = pre[cur]) {",
            "                path.push_back(cur);",
            "            }",
            "            reverse(path.begin(), path.end());",
            "            for(int x : path) {",
            "                cout << x << \" \";",
            "            }",
            "            return;  ",
            "        }",
            "        for(int i = h[f]; i!=-1; i= ne[i]){",
            "            int j = e[i];",
            "            if(!st[j]){",
            "                st[j] = true;",
            "                pre[j] = f;  ",
            "                q.push(j);",
            "            }",
            "        }",
            "    }",
            "",
            "}"
        ],
        "description": "Snippet from BFS 2",
        "scope": "cpp"
    },
    "Binary search": {
        "prefix": "Binary search",
        "body": [
            "",
            "int n;",
            "int d[1000000];//升序",
            "",
            "",
            "int binary_search_l(int x){",
            "    auto check = [&](int mid_){",
            "        return d[mid_]>=x;//开区间改成 >",
            "    };",
            "    int l = 0; int r = n-1;",
            "    while(l<r){",
            "       int mid = (l+r)/2;",
            "       if(check(mid)){",
            "            r = mid;",
            "       } ",
            "       else {",
            "            l = mid+1;",
            "       }",
            "       cout<<l<<\" \"<<r<<endl;",
            "    }",
            "    return r;",
            "}",
            "int binary_search_r(int x){",
            "    auto check = [&](int mid_){",
            "        return d[mid_]<=x;//开区间改成 <",
            "    };",
            "    int l = 0; int r = n-1;",
            "    while(l<r){",
            "       int mid = (l+r+1)/2;",
            "       if(check(mid)){",
            "            l = mid;",
            "       } ",
            "       else {",
            "            r = mid-1;",
            "       }",
            "       cout<<l<<\" \"<<r<<endl;",
            "    }",
            "    return l;",
            "}"
        ],
        "description": "Snippet from Binary search",
        "scope": "cpp"
    },
    "Date iterator": {
        "prefix": "Date iterator",
        "body": [
            "/*",
            "2024-11-16日xx贺被蓝桥杯模拟赛的某道日期题目恶心坏了,",
            "于是连夜手搓了这个遍历日期的板子, (纯代码15行), 毕竟咱和python还是比不了",
            "更新:",
            "update on 2024/11/17",
            "封装成了类",
            "##### OS:",
            "我觉得罪魁祸首是每个月的天数不同, 真该死啊, 要是每个月都是30天就好了",
            "##### 代码功能:",
            "给定起始日期和结束日期, 能够遍历得到区间内每一天的日期",
            "*/",
            "",
            "class Date {",
            "public:",
            "    const int rq[13] = {29, 31, 28, 31, 30, 31, 30,31, 31, 30, 31, 30, 31};  // r[2]平年, rq[0] 是闰年",
            "    bool check(int yy) {",
            "        return ((yy % 4 == 0 && yy % 100 != 0) || (yy % 400 == 0));",
            "    }",
            "    int yy, mm, dd;",
            "    Date(int year, int month, int day) {  // 不带默认值的构造函数",
            "        yy = year, mm = month, dd = day;",
            "    }",
            "    void nextDay() {",
            "        if ((!check(yy) && dd == rq[mm]) || (check(yy) && mm == 2 ? dd == rq[0] : dd == rq[mm])) {",
            "            dd = 1, mm++;",
            "            if (mm > 12) mm = 1, yy++;",
            "        } else dd++;",
            "    }",
            "    bool isSame(Date d) {",
            "        return d.getDay() == dd && d.getMonth() == mm && d.getYear() == yy;",
            "    }",
            "    void print() const { printf(\"%d-%02d-%02d\\n\", yy, mm, dd); }",
            "    int getYear() const { return yy; }",
            "    int getMonth() const { return mm; }",
            "    int getDay() const { return dd; }",
            "};",
            "/*",
            "",
            "example :",
            "int main() {",
            "    int yy = 2023, mm = 12, dd = 1;   // 起始日期",
            "    int YY = 2024, MM = 12, DD = 31;  // 结束日期",
            "    Date start(yy, mm, dd);",
            "    Date end(YY, MM, DD);",
            "    while (true) {",
            "        start.print();",
            "        if (start.isSame(end)) break;",
            "        start.nextDay();",
            "    }",
            "    return 0;",
            "}",
            "*/"
        ],
        "description": "Snippet for Date iterator in cpp",
        "scope": "cpp"
    },
    "DFS": {
        "prefix": "DFS",
        "body": [],
        "description": "Snippet from DFS",
        "scope": "cpp"
    },
    "Dijkstra": {
        "prefix": "Dijkstra",
        "body": [
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "",
            "typedef pair<int,int> PII;",
            "const int N=151000;",
            "",
            "int h[N],e[N],w[N],ne[N],idx;",
            "",
            "int n,m;",
            "",
            "bool st[N];",
            "int dis[N];",
            "void add(int a,int b,int c)",
            "{",
            "    e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;",
            "}",
            "",
            "int dijkstra()",
            "{",
            "    memset(dis,0x3f,sizeof dis);",
            "    dis[1]=0;",
            "",
            "    priority_queue<PII,vector<PII>,greater<PII>> heap;",
            "    heap.emplace(0,1);",
            "",
            "    while(heap.size())",
            "    {",
            "        auto t=heap.top();",
            "        heap.pop();",
            "        int ver=t.second;",
            "        if(st[ver])continue;",
            "        st[ver]=true;",
            "        for(int i=h[ver];i!=-1;i=ne[i])",
            "        {",
            "            int j=e[i];",
            "            if(dis[j]>dis[ver]+w[i])",
            "            {",
            "                dis[j]=dis[ver]+w[i];",
            "                heap.emplace(dis[j],j);",
            "            }",
            "        }",
            "",
            "    }",
            "    if(dis[n]==0x3f3f3f3f)return -1;",
            "    return dis[n];",
            "}",
            "",
            "int main()",
            "{",
            "    memset(h,-1,sizeof h);",
            "    cin>>n>>m;",
            "    for(int i=0;i<m;i++)",
            "    {",
            "        int a,b,c;",
            "        cin>>a>>b>>c;",
            "        add(a,b,c);",
            "    }",
            "    cout<<dijkstra()<<endl;",
            "    return 0;",
            "}"
        ],
        "description": "Snippet from Dijkstra",
        "scope": "cpp"
    },
    "Floyd": {
        "prefix": "Floyd",
        "body": [
            "const int N  =450;",
            "int dp[N][N];",
            "int n;",
            "void init(){",
            "\tmemset(dp,0x3f,sizeof dp);",
            "\tfor(int i = 1;i<=n;i++)",
            "\t{",
            "\t\tdp[i][i] = min(dp[i][i],0);",
            "\t}",
            "}",
            "void add(int a,int b,int c)",
            "{",
            "\tdp[a][b] = min(dp[a][b],c);",
            "}",
            "",
            "void Floyd(){",
            "\tfor(int k =1;k<=n;k++){",
            "\t\tfor (int i =1;i<=n;i++){",
            "\t\t\tfor(int j = 1;j<=n;j++){",
            "\t\t\t\tdp[i][j] = min(dp[i][j],dp[i][k]+dp[k][j]);\t\t\t",
            "\t\t\t}",
            "\t\t}",
            "\t}\t",
            "}"
        ],
        "description": "Snippet from Floyd",
        "scope": "cpp"
    },
    "Forward Star": {
        "prefix": "Forward Star",
        "body": [
            "const int N = 1e5+10;",
            "int h[N] ,e[N],ne[N],idx;"
        ],
        "description": "Snippet from Forward Star",
        "scope": "cpp"
    },
    "Group Knapsack": {
        "prefix": "Group Knapsack",
        "body": [
            "// 分组背包",
            "int group_knapsack(int n, const vector<vector<int>>& w, const vector<vector<int>>& v, int V) {",
            "    /*",
            "    w : 每组物品的重量",
            "    v : 每组物品的价值",
            "    V : 背包容量",
            "    */",
            "    vector<int> dp(V + 1, 0); // dp[i] 表示容量为 i 时的最大价值",
            "    for (int i = 0; i < n; ++i) {",
            "        vector<int> temp = dp; // 临时保存上一次的状态",
            "        for (int j = 0; j < w[i].size(); ++j) {",
            "            for (int k = V; k >= w[i][j]; --k) {",
            "                temp[k] = max(temp[k], dp[k - w[i][j]] + v[i][j]);",
            "            }",
            "        }",
            "        dp = temp; // 更新 dp 数组",
            "    }",
            "    return dp[V]; // 返回最大价值",
            "}",
            ""
        ],
        "description": "Snippet for Group Knapsack in cpp",
        "scope": "cpp"
    },
    "Header Sungq": {
        "prefix": "Header Sungq",
        "body": [
            "#ifndef Preproccess",
            "#define Preproccess",
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "#define GET_MACRO(_1, _2, _3, _4, NAME, ...) NAME",
            "#define REP1(d) for (int i = 0; i != (d); ++i)",
            "#define REP2(s,e) for (int i = (s); i != (e); ++i)",
            "#define REP3(s,e,d) for (int i = (s); i != (e); i += (d))",
            "#define REP4(i,s,e,d) for ((i) = (s); (i) != (e); (i) += (d))",
            "#define REP(...) GET_MACRO(__VA_ARGS__, REP4, REP3, REP2, REP1)(__VA_ARGS__)",
            "#define FastIOS {ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);}",
            "#define int long long",
            "using i64 = long long;",
            "using i128 = __int128;",
            "using pii = pair<int, int>;",
            "using u64 = unsigned long long;",
            "using u128 = __uint128_t;",
            "using ll = i64;",
            "#define f32 float",
            "#define f64 double",
            "#define endl \"\\n\"",
            "#define pi acos(-1)",
            "#define all(v) v.begin(),v.end()",
            "#define pb push_back",
            "#define x first",
            "#define y second",
            "int dx[4] = {0,0,1,-1};",
            "int dy[4] = {1,-1,0,0};",
            "#define inf 0x3f3f3f3f3f3f3f3f",
            "#define INF inf",
            "namespace std{",
            "template <>",
            "struct hash<pair<int, int>> {",
            "    u64 operator()(const pair<int, int>& p) const {",
            "        u64 h1 = hash<int>()(p.first);",
            "        u64 h2 = hash<int>()(p.second);",
            "        return (h1 +h2)*(h1+h2+1)/2+h2;",
            "    }",
            "};",
            "}",
            "",
            "template <typename T>",
            "struct has_iter {",
            "private:",
            "    template <typename U>",
            "    static constexpr decltype(std::declval<U>().begin(), std::true_type{}) test(int);",
            "    template <typename>",
            "    static constexpr std::false_type test(...);",
            "public:",
            "    static constexpr bool value = decltype(test<T>(0))::value;",
            "};",
            "",
            "void indent(int d) {",
            "    for (int i = 0; i < d; ++i) std::cout << \"    \";",
            "}",
            "",
            "template <typename T, typename std::enable_if<!has_iter<T>::value, int>::type = 0>",
            "void dbg(const T& x, int d = 0) {",
            "    std::cout << x;",
            "}",
            "template <typename T, typename std::enable_if<has_iter<T>::value && !has_iter<typename T::value_type>::value, int>::type = 0>",
            "void dbg(const T& x, int d = 0) {",
            "    std::cout << \"{\";",
            "    bool f = true;",
            "    for (const auto& e : x) {",
            "        if (!f) std::cout << \", \";",
            "        f = false;",
            "        dbg(e, d);",
            "    }",
            "    std::cout << \"}\";",
            "}",
            "template <typename T, typename std::enable_if<has_iter<T>::value && has_iter<typename T::value_type>::value, int>::type = 0>",
            "void dbg(const T& x, int d = 0) {",
            "    std::cout << \"{\\n\";",
            "    for (const auto& r : x) {",
            "        indent(d + 1);",
            "        dbg(r, d + 1);",
            "        std::cout << \"\\n\";",
            "    }",
            "    indent(d);",
            "    std::cout << \"}\";",
            "}",
            "",
            "#define debug(_x) { \\",
            "    std::cout << #_x << \" = \\n\"; \\",
            "    dbg(_x); \\",
            "    std::cout << \"\\n\"; \\",
            "}",
            "#endif",
            "/*",
            "",
            "    This Header is written by Guoqing Sun. which is a template for algorithm contest.",
            "",
            "*/",
            "void solve()",
            "{",
            " ",
            "}",
            "signed main(){",
            "    FastIOS;",
            "    solve();",
            "    return 0;",
            "}"
        ],
        "description": "Snippet for Header Sungq in cpp",
        "scope": "cpp"
    },
    "Header": {
        "prefix": "Header",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define fast ios ::sync_with_stdio(false), cin.tie(0), cout.tie(0)",
            "#define endl '\\n'",
            "using ll = long long;",
            "#define int long long",
            "#define OUT(v)                         \\",
            "    for (int k = 0; k < v.size(); ++k) \\",
            "        cout << v[k] << ' ';           \\",
            "    cout << endl;",
            "const int N = 1e5 + 10;",
            "int h[N], e[2 * N], ne[N];",
            "const int MOD = 1e9 + 7;",
            "int mul(int x, int y) {return 1LL * x * y % MOD; }",
            "int fact[N], ifact[N];"
        ],
        "description": "Snippet for Header in cpp",
        "scope": "cpp"
    },
    "High precision": {
        "prefix": "High precision",
        "body": [
            "// This code is used to implement high precision arithmetic.",
            "class HP {",
            "private:",
            "    string intPart, decPart;",
            "",
            "    void norm() {",
            "        if (decPart.empty() || all_of(decPart.begin(), decPart.end(), [](char c) { return c == '0'; }))",
            "            decPart.clear();",
            "    }",
            "",
            "public:",
            "    HP() : intPart(\"0\"), decPart(\"\") {}",
            "",
            "    HP(string val) {",
            "        size_t p = val.find('.');",
            "        if (p != string::npos) {",
            "            intPart = val.substr(0, p);",
            "            decPart = val.substr(p + 1);",
            "        } else {",
            "            intPart = val;",
            "            decPart.clear();",
            "        }",
            "        norm();",
            "    }",
            "",
            "    HP(int val) {",
            "        intPart = to_string(val);",
            "        decPart.clear();",
            "    }",
            "",
            "    HP(long long val) {",
            "        intPart = to_string(val);",
            "        decPart.clear();",
            "    }",
            "",
            "    HP(size_t val) {",
            "        intPart = to_string(val);",
            "        decPart.clear();",
            "    }",
            "",
            "    HP(double val) {",
            "        stringstream ss;",
            "        ss << val;",
            "        string s = ss.str();",
            "        size_t p = s.find('.');",
            "        if (p != string::npos) {",
            "            intPart = s.substr(0, p);",
            "            decPart = s.substr(p + 1);",
            "        } else {",
            "            intPart = s;",
            "            decPart.clear();",
            "        }",
            "        norm();",
            "    }",
            "",
            "    operator string() const {",
            "        return intPart + (decPart.empty() ? \"\" : \".\" + decPart);",
            "    }",
            "",
            "    operator double() const {",
            "        return stod(intPart) + (decPart.empty() ? 0.0 : stod(\"0.\" + decPart));",
            "    }",
            "",
            "    HP operator+(const HP& o) const {",
            "        string resInt = intPart, resDec = decPart;",
            "        int maxDec = max(decPart.size(), o.decPart.size());",
            "        if (decPart.size() < maxDec) resDec.append(maxDec - decPart.size(), '0');",
            "        if (o.decPart.size() < maxDec) resDec.append(maxDec - o.decPart.size(), '0');",
            "        ",
            "        int carry = 0, i = resDec.size() - 1;",
            "        while (i >= 0) {",
            "            int sum = resDec[i] - '0' + o.decPart[i] - '0' + carry;",
            "            carry = sum / 10;",
            "            resDec[i] = sum % 10 + '0';",
            "            --i;",
            "        }",
            "        return HP(resInt + \".\" + resDec);",
            "    }",
            "",
            "    HP operator+(int o) const {",
            "        return *this + HP(o);",
            "    }",
            "",
            "    HP operator+(long long o) const {",
            "        return *this + HP(o);",
            "    }",
            "",
            "    HP operator+(size_t o) const {",
            "        return *this + HP(o);",
            "    }",
            "",
            "    HP operator+(double o) const {",
            "        return *this + HP(o);",
            "    }",
            "",
            "    HP operator-(const HP& o) const {",
            "        string resInt = intPart, resDec = decPart;",
            "        int maxDec = max(decPart.size(), o.decPart.size());",
            "        if (decPart.size() < maxDec) resDec.append(maxDec - decPart.size(), '0');",
            "        if (o.decPart.size() < maxDec) resDec.append(maxDec - o.decPart.size(), '0');",
            "        ",
            "        int borrow = 0, i = resDec.size() - 1;",
            "        while (i >= 0) {",
            "            int diff = resDec[i] - '0' - o.decPart[i] + '0' - borrow;",
            "            if (diff < 0) { diff += 10; borrow = 1; } else borrow = 0;",
            "            resDec[i] = diff + '0';",
            "            --i;",
            "        }",
            "        return HP(resInt + \".\" + resDec);",
            "    }",
            "",
            "    HP operator-(int o) const {",
            "        return *this - HP(o);",
            "    }",
            "",
            "    HP operator-(long long o) const {",
            "        return *this - HP(o);",
            "    }",
            "",
            "    HP operator-(size_t o) const {",
            "        return *this - HP(o);",
            "    }",
            "",
            "    HP operator-(double o) const {",
            "        return *this - HP(o);",
            "    }",
            "",
            "    HP operator*(const HP& o) const {",
            "        string resInt = intPart + decPart, oInt = o.intPart + o.decPart;",
            "        vector<int> prod(resInt.size() + oInt.size(), 0);",
            "        ",
            "        for (int i = resInt.size() - 1; i >= 0; --i) ",
            "            for (int j = oInt.size() - 1; j >= 0; --j) {",
            "                int mul = (resInt[i] - '0') * (oInt[j] - '0');",
            "                prod[i + j + 1] += mul;",
            "            }",
            "        ",
            "        for (int i = prod.size() - 1; i > 0; --i) {",
            "            prod[i - 1] += prod[i] / 10;",
            "            prod[i] %= 10;",
            "        }",
            "        ",
            "        string result;",
            "        bool leadingZero = true;",
            "        for (int i = 0; i < prod.size(); ++i) {",
            "            if (leadingZero && prod[i] == 0) continue;",
            "            leadingZero = false;",
            "            result.push_back(prod[i] + '0');",
            "        }",
            "        ",
            "        int decLen = decPart.size() + o.decPart.size();",
            "        if (decLen > 0) result.insert(result.size() - decLen, \".\");",
            "        ",
            "        return HP(result);",
            "    }",
            "",
            "    HP operator*(int o) const {",
            "        return *this * HP(o);",
            "    }",
            "",
            "    HP operator*(long long o) const {",
            "        return *this * HP(o);",
            "    }",
            "",
            "    HP operator*(size_t o) const {",
            "        return *this * HP(o);",
            "    }",
            "",
            "    HP operator*(double o) const {",
            "        return *this * HP(o);",
            "    }",
            "",
            "    HP operator/(const HP& o) const {",
            "        if (o.intPart == \"0\" && o.decPart == \"0\") throw invalid_argument(\"0不能作除数\");",
            "        return *this;  ",
            "    }",
            "",
            "    HP operator/(int o) const {",
            "        return *this / HP(o);",
            "    }",
            "",
            "    HP operator/(long long o) const {",
            "        return *this / HP(o);",
            "    }",
            "",
            "    HP operator/(size_t o) const {",
            "        return *this / HP(o);",
            "    }",
            "",
            "    HP operator/(double o) const {",
            "        return *this / HP(o);",
            "    }",
            "",
            "",
            "    HP powIntPart(int exp) const {",
            "        if (exp < 0) throw invalid_argument(\"指数不能为负数\");",
            "        ",
            "",
            "        string result = \"1\";  ",
            "        string base = intPart;",
            "        while (exp > 0) {",
            "            if (exp % 2 == 1) { ",
            "                result = multiplyStrings(result, base);",
            "            }",
            "            base = multiplyStrings(base, base); ",
            "            exp /= 2; ",
            "        }",
            "        return HP(result);",
            "    }",
            "",
            "private:",
            " ",
            "    string multiplyStrings(const string& num1, const string& num2) const {",
            "        int len1 = num1.size(), len2 = num2.size();",
            "        vector<int> result(len1 + len2, 0);",
            "        ",
            "     ",
            "        for (int i = len1 - 1; i >= 0; --i) {",
            "            for (int j = len2 - 1; j >= 0; --j) {",
            "                int mul = (num1[i] - '0') * (num2[j] - '0');",
            "                int sum = mul + result[i + j + 1];",
            "                result[i + j + 1] = sum % 10;",
            "                result[i + j] += sum / 10;",
            "            }",
            "        }",
            "        ",
            "       ",
            "        string res;",
            "        for (int i = 0; i < result.size(); ++i) {",
            "            if (!(res.empty() && result[i] == 0)) {",
            "                res.push_back(result[i] + '0');",
            "            }",
            "        }",
            "        ",
            "        return res.empty() ? \"0\" : res;",
            "    }",
            "\tfriend istream& operator>>(istream& is, HP& h) {",
            "\t    string val;",
            "\t    is >> val; ",
            "",
            "\t    size_t p = val.find('.');",
            "\t    if (p != string::npos) {",
            "\t        h.intPart = val.substr(0, p); ",
            "\t        h.decPart = val.substr(p + 1);",
            "\t    } else {",
            "\t        h.intPart = val;",
            "\t        h.decPart.clear();",
            "\t    }",
            "\t    h.norm();",
            "\t",
            "\t    return is;",
            "\t}",
            "\t",
            "\tfriend ostream& operator<<(ostream& os, const HP& h) {",
            "\t    string str = h.intPart;  ",
            "\t",
            "\t    if (!h.decPart.empty()) {",
            "\t        str += \".\" + h.decPart;",
            "\t    }",
            "\t",
            "\t    if (os.flags() & ios::fixed) {",
            "\t        size_t dPos = str.find('.');",
            "\t        if (dPos != string::npos) {",
            "\t        ",
            "\t            while (str.back() == '0') str.pop_back();",
            "\t",
            "\t            if (str.back() == '.') str.pop_back();",
            "\t        }",
            "\t",
            "\t        if (os.precision() > 0) {",
            "\t            size_t reqDec = os.precision() - (str.size() - dPos - 1);",
            "\t            str.append(reqDec, '0');",
            "\t        }",
            "\t    }",
            "\t",
            "\t    os << str;",
            "\t    return os;",
            "\t}",
            "",
            "};",
            "",
            "",
            "",
            "vector <int>  add (vector <int> & A,vector<int> & B){",
            "\tint tem = 0 ;",
            "\tvector <int> res;",
            "\tif(A.size()>B.size())return add(B,A);",
            "\tfor(int i =0 ; i <B.size();i++){",
            "\t\ttem += B[i];",
            "\t\tif(i<A.size()) tem+=A[i];",
            "\t\tres.push_back(tem%10);",
            "\t\ttem = tem/10; ",
            "\t}",
            "\tif(tem)res.push_back(tem);",
            "\treturn res;",
            "}",
            "//A>B",
            "vector<int> sub(vector<int>& A,vector<int > & B){",
            "\tint tem = 0;",
            "\tvector<int> res;",
            "\tfor(int i = 0; i < A.size();i++){",
            "\t\ttem =A[i] - tem;",
            "\t\tif(i< B.size()) tem = tem - B[i];",
            "\t\tres.push_back((10+tem)%10);",
            "\t\tif(tem<0)tem =1;",
            "\t\telse tem =0;",
            "\t}",
            "\twhile (res.size()>1 &&res.back() == 0)res.pop_back();",
            "\treturn res;",
            "}",
            "vector<int> mul (vector<int> & A ,int b){",
            "\tvector<int> res ;",
            "\tint tem = 0 ;",
            "\t for(int i =0 ;i <A.size()||tem;i++){",
            "\t \tif(i<A.size())tem += (A[i]*b);",
            "\t \tres.push_back(tem%10);",
            "\t\ttem /=10;",
            "\t }",
            "\treturn res;",
            "}",
            "vector<int> div(vector<int> A ,int b,int & mod){",
            "\tvector<int> res;",
            "\tmod= 0 ;",
            "\tfor(int i = A.size()-1;i>=0;i--){",
            "\t\tmod = 10*mod +A[i];",
            "\t\tres.push_back(mod/b);",
            "\t\tmod%=b;",
            "\t}",
            "\treverse(res.begin(),res.end());",
            "\twhile(res.size()>1&&res.back()==0)res.pop_back();",
            "\treturn res;",
            "}",
            "#include <iostream>",
            "using namespace std;",
            "",
            "/*",
            "example:",
            "    // 1. 创建与初始化测试",
            "    HP h1(\"123.456\"); // 字符串输入，带小数部分",
            "    HP h2(123);       // 整数输入",
            "    HP h3(123456789012345); // 长整型输入",
            "    HP h4(123.456);   // 双精度浮点数输入",
            "    ",
            "    cout << \"通过字符串 '123.456' 创建的 HP: \" << h1 << endl;",
            "    cout << \"通过整数 123 创建的 HP: \" << h2 << endl;",
            "    cout << \"通过长整型创建的 HP: \" << h3 << endl;",
            "    cout << \"通过双精度浮点数 123.456 创建的 HP: \" << h4 << endl;",
            "",
            "    // 2. 算术运算测试",
            "    HP h5 = h1 + h2;  // HP + int",
            "    cout << \"h1 + h2: \" << h5 << endl;",
            "",
            "    HP h6 = h1 - h2;  // HP - int",
            "    cout << \"h1 - h2: \" << h6 << endl;",
            "",
            "    HP h7 = h1 * h2;  // HP * int",
            "    cout << \"h1 * h2: \" << h7 << endl;",
            "",
            "    HP h8 = h1 / h2;  // HP / int",
            "    cout << \"h1 / h2: \" << h8 << endl;",
            "",
            "    // 3. 整数部分的指数运算测试",
            "    HP h9 = h1.powIntPart(2);  // 整数部分的指数运算",
            "    cout << \"h1 ^ 2: \" << h9 << endl;",
            "",
            "    // 4. 输入输出流测试",
            "    HP h10;",
            "    cout << \"请输入一个数给 HP: \";",
            "    cin >> h10;  // 用户输入",
            "    cout << \"您输入的是: \" << h10 << endl;",
            "",
            "    // 5. 边界情况: 除以零",
            "    try {",
            "        HP h11(\"0\");",
            "        HP h12 = h1 / h11;  // 应该抛出异常",
            "    } catch (const invalid_argument& e) {",
            "        cout << \"捕获到异常: \" << e.what() << endl;",
            "    }",
            "",
            "/*",
            ""
        ],
        "description": "Snippet for High precision in cpp",
        "scope": "cpp"
    },
    "High speed IO": {
        "prefix": "High speed IO",
        "body": [
            "inline void fast_io() {",
            "    ios::sync_with_stdio(false);  ",
            "    cin.tie(0);  ",
            "    cout.tie(0);  ",
            "}",
            "",
            "template <typename T>",
            "inline T read() {",
            "    T x = 0;",
            "    char c;",
            "    bool neg = false;",
            "    while ((c = getchar()) < '0' || c > '9') {",
            "        if (c == '-') {",
            "            neg = true;",
            "        }",
            "    }",
            "    do {",
            "        x = x * 10 + (c - '0');",
            "    } while ((c = getchar()) >= '0' && c <= '9');",
            "    return neg ? -x : x;",
            "}",
            "",
            "template <>",
            "inline double read<double>() {",
            "    double x = 0.0;",
            "    char c;",
            "    bool neg = false;",
            "    while ((c = getchar()) < '0' || c > '9') {",
            "        if (c == '-') {",
            "            neg = true;",
            "        }",
            "    }",
            "    do {",
            "        x = x * 10 + (c - '0');",
            "    } while ((c = getchar()) >= '0' && c <= '9');",
            "    if (c == '.') {",
            "        double frac = 1;",
            "        while ((c = getchar()) >= '0' && c <= '9') {",
            "            frac /= 10;",
            "            x += (c - '0') * frac;",
            "        }",
            "    }",
            "    return neg? -x : x;",
            "}",
            "",
            "template <typename T>",
            "inline void write(const T &x) {",
            "    if constexpr (is_integral<T>::value) {",
            "        if (x < 0) {",
            "            putchar('-');",
            "            write(-x);",
            "        } else {",
            "            if (x >= 10) {",
            "                write(x / 10);",
            "            }",
            "            putchar(x % 10 + '0');",
            "        }",
            "    } else if constexpr (is_floating_point<T>::value) {",
            "        printf(\"%.6f\", x);",
            "    }",
            "}"
        ],
        "description": "Snippet from High speed IO",
        "scope": "cpp"
    },
    "KMP": {
        "prefix": "KMP",
        "body": [
            "#define sequence vector<char>",
            "#define dict vector<int> ",
            "sequence text;",
            "sequence pat;",
            "",
            "int kmp(sequence &text,sequence &pat){",
            "\tdict next(pat.size(),0);",
            "\tauto getNext = [&](){",
            "\t\tfor (int i = 1, j = 0; i < pat.size(); i++) {",
            "\t\t\twhile (j > 0 && pat[i] != pat[j]) j = next[j - 1];",
            "\t\t\tif (pat[i] == pat[j]) j++;",
            "\t\t\tnext[i] = j;",
            "\t\t}",
            "\t};",
            "\tgetNext();",
            "\tfor (int i = 0, j = 0; i < text.size(); i++) {",
            "\t\twhile (j > 0 && text[i] != pat[j]) j = next[j - 1];",
            "\t\tif (text[i] == pat[j]) j++;",
            "\t\tif (j == pat.size()) return i - pat.size() + 1;",
            "\t}",
            "\t",
            "}",
            "/*",
            "",
            "int main(){",
            "\tstring t;",
            "\tstring p;",
            "\tcin>>t>>p;",
            "\tfor(auto c:t) text.push_back(c);",
            "\tfor(auto c:p) pat.push_back(c);",
            "\tcout<<kmp(text,pat)<<endl;",
            "",
            "",
            "\treturn 0;",
            "}",
            "",
            "*/"
        ],
        "description": "Snippet from KMP",
        "scope": "cpp"
    },
    "Kruskal": {
        "prefix": "Kruskal",
        "body": [],
        "description": "Snippet from Kruskal",
        "scope": "cpp"
    },
    "Math": {
        "prefix": "Math",
        "body": [
            "typedef long long LL;",
            "int qmi(int a, int k, int p) {",
            "    LL res = 1;",
            "    while(k) {",
            "        if(k & 1) res = (LL)res * a % p;",
            "        k >>= 1;",
            "        a = (LL)a * a % p;",
            "    }",
            "    return res;",
            "}",
            "typedef long long ll;",
            "ll qmi(int a, int p) {",
            "    int k = p - 2;",
            "    ll res = 1;",
            "    while(k) {",
            "        if(k & 1) res = (ll)res * a % p;",
            "        k >>= 1;",
            "        a = (ll)a * a % p;",
            "    }",
            "    return res;",
            "}",
            "void exgcd(int a, int b, int &x, int &y) {",
            "    if(!b) {",
            "        x = 1, y = 0;",
            "        return;",
            "    }",
            "    exgcd(b, a % b, y, x);",
            "    y -= a / b * x;",
            "}",
            "int phi(int x) {",
            "    int res = x;",
            "    for (int i = 2; i <= x / i; i++) {",
            "        if (x % i == 0) {",
            "            res = res / i * (i - 1);",
            "            while(x % i == 0) x /= i;",
            "        }",
            "    }",
            "    if(x > 1) res = res / x * (x - 1);",
            "    return res;",
            "}",
            "void divisors(int n) {",
            "    for(int i = 1; i <= n / i; i++) {",
            "        if(n % i == 0) {",
            "            cout << i << endl;",
            "            if(i != n / i) cout << n / i << endl;",
            "        }",
            "    }",
            "}",
            "int gcd(int a, int b) {",
            "    return b ? gcd(b, a % b) : a;",
            "}",
            "int lcm(int a, int b) {",
            "    return a / gcd(a, b) * b; // 先除后乘，防止溢出",
            "}",
            "bool Is_prime(int x) {",
            "    if(x < 2) return false;",
            "    for(int i = 2; i <= x / i; i++)",
            "        if(x % i == 0) return false;",
            "    return true;",
            "}",
            "void divided(int x) {",
            "    for(int i = 2; i <= x / i; i++) {",
            "        if(x % i == 0) {",
            "            int s = 0;",
            "            while(x % i == 0) {",
            "                x /= i;",
            "                s++;",
            "            }",
            "            printf(\"%d %d\\n\", i, s);",
            "        }",
            "    }",
            "    if(x > 1) printf(\"%d 1\\n\", x);",
            "    puts(\" \");",
            "}",
            "void get_primes(int n) {",
            "    for(int i = 2; i <= n; i++) {",
            "        if(!st[i]) {",
            "            primes[cnt++] = i;",
            "            for(int j = i + i; j <= n; j += i)",
            "                st[j] = true;",
            "        }",
            "    }",
            "}",
            "void get_primes_linear(int n) {",
            "    for (int i = 2; i <= n; i++) {",
            "        if(!st[i]) primes[cnt++] = i;",
            "        for (int j = 0; primes[j] <= n / i; j++) {",
            "            st[primes[j] * i] = true;",
            "            if(i % primes[j] == 0) break;",
            "        }",
            "    }",
            "}"
        ],
        "description": "Snippet from Math",
        "scope": "cpp"
    },
    "Merge Sort": {
        "prefix": "Merge Sort",
        "body": [
            "const int N =10010;",
            "int tmp[N];",
            "",
            "void merge_sort(int q[],int l ,int r){",
            "\tif(l>=r)return;",
            "\tint mid = (l + r)  >>1;",
            "\tmerge_sort(q,l,mid);",
            "\tmerge_sort(q,mid+1,r);",
            "\tint k = 0, i = l, j = mid+1;",
            "\twhile(i<=mid&&j<=r){",
            "\t\tif(q[i]<=q[j])tmp[k++] = q[i++];",
            "\t\telse tmp[k++]= q[j++];",
            "\t}",
            "\twhile(i<=mid)tmp[k++] = q[i++];",
            "\twhile(j<=r)tmp[k++] = q[j++];",
            "\tfor(int i = 0,j = l;j<=r;i++,j++) q[j]=tmp[i];",
            "}"
        ],
        "description": "Snippet from Merge Sort",
        "scope": "cpp"
    },
    "multiCase": {
        "prefix": "multiCase",
        "body": [
            "int t;",
            "void solve(){",
            "",
            "}",
            "signed main() ",
            "{",
            "    cin>>t;",
            "    while(t--)",
            "    {",
            "        solve();",
            "    }",
            "    return 0;",
            "}"
        ],
        "description": "Snippet for multiCase in cpp",
        "scope": "cpp"
    },
    "Multiple Knapsack": {
        "prefix": "Multiple Knapsack",
        "body": [
            "// 多重背包",
            "int multiple_knapsack(int n, const vector<int>& w, const vector<int>& v, const vector<int>& c, int V) {",
            "    /*",
            "    w : 物品的重量",
            "    v : 物品的价值",
            "    c : 每种物品的最大数量",
            "    V : 背包容量",
            "    */",
            "    vector<int> dp(V + 1, 0); // dp[i] 表示容量为 i 时的最大价值",
            "    for (int i = 0; i < n; ++i) {",
            "        for (int k = 1; k <= c[i]; k <<= 1) { // 二进制拆分",
            "            int count = min(c[i] - (k - 1), V / (k * w[i]));",
            "            for (int j = V; j >= k * w[i]; --j) {",
            "                dp[j] = max(dp[j], dp[j - k * w[i]] + k * v[i]);",
            "            }",
            "        }",
            "    }",
            "    return dp[V]; // 返回最大价值",
            "}"
        ],
        "description": "Snippet for Multiple Knapsack in cpp",
        "scope": "cpp"
    },
    "Prim": {
        "prefix": "Prim",
        "body": [],
        "description": "Snippet from Prim",
        "scope": "cpp"
    },
    "pyMain": {
        "prefix": "pyMain",
        "body": [
            "# Visit my repo: https://github.com/Departag1an/-",
            "standard_input, packages, output_together = 1, 1, 0",
            "dfs, hashing, read_from_file = 0, 0, 0",
            "de = 1",
            "",
            "if 1:",
            "",
            "    if standard_input:",
            "        import io, os, sys",
            "        input = lambda: sys.stdin.readline().strip()",
            "",
            "        import math",
            "        inf = math.inf",
            "",
            "        def I():",
            "            return input()",
            "        ",
            "        def II():",
            "            return int(input())",
            "",
            "",
            "        def MII():",
            "            return map(int, input().split())",
            "",
            "        def LI():",
            "            return input().split()",
            "",
            "        def LII():",
            "            return list(map(int, input().split()))",
            "",
            "        def LFI():",
            "            return list(map(float, input().split()))",
            "",
            "        def GMI():",
            "            return map(lambda x: int(x) - 1, input().split())",
            "",
            "        def LGMI():",
            "            return list(map(lambda x: int(x) - 1, input().split()))",
            "",
            "    if packages:",
            "        from io import BytesIO, IOBase",
            "",
            "        import random",
            "        import os",
            "",
            "        import bisect",
            "        import typing",
            "        from collections import Counter, defaultdict, deque",
            "        from copy import deepcopy",
            "        from functools import cmp_to_key, lru_cache, reduce",
            "        from heapq import merge, heapify, heappop, heappush, heappushpop, nlargest, nsmallest",
            "        from itertools import accumulate, combinations, permutations, count, product",
            "        from operator import add, iand, ior, itemgetter, mul, xor",
            "        from string import ascii_lowercase, ascii_uppercase, ascii_letters",
            "        from typing import *",
            "        BUFSIZE = 4096",
            "",
            "    if output_together:",
            "        class FastIO(IOBase):",
            "            newlines = 0",
            "",
            "            def __init__(self, file):",
            "                self._fd = file.fileno()",
            "                self.buffer = BytesIO()",
            "                self.writable = \"x\" in file.mode or \"r\" not in file.mode",
            "                self.write = self.buffer.write if self.writable else None",
            "",
            "            def read(self):",
            "                while True:",
            "                    b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
            "                    if not b:",
            "                        break",
            "                    ptr = self.buffer.tell()",
            "                    self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
            "                self.newlines = 0",
            "                return self.buffer.read()",
            "",
            "            def readline(self):",
            "                while self.newlines == 0:",
            "                    b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
            "                    self.newlines = b.count(b\"\\n\") + (not b)",
            "                    ptr = self.buffer.tell()",
            "                    self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
            "                self.newlines -= 1",
            "                return self.buffer.readline()",
            "",
            "            def flush(self):",
            "                if self.writable:",
            "                    os.write(self._fd, self.buffer.getvalue())",
            "                    self.buffer.truncate(0), self.buffer.seek(0)",
            "",
            "        class IOWrapper(IOBase):",
            "            def __init__(self, file):",
            "                self.buffer = FastIO(file)",
            "                self.flush = self.buffer.flush",
            "                self.writable = self.buffer.writable",
            "                self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))",
            "                self.read = lambda: self.buffer.read().decode(\"ascii\")",
            "                self.readline = lambda: self.buffer.readline().decode(\"ascii\")",
            "",
            "        sys.stdout = IOWrapper(sys.stdout)",
            "",
            "    if dfs:",
            "        from types import GeneratorType",
            "",
            "        def bootstrap(f, stk=[]):",
            "            def wrappedfunc(*args, **kwargs):",
            "                if stk:",
            "                    return f(*args, **kwargs)",
            "                else:",
            "                    to = f(*args, **kwargs)",
            "                    while True:",
            "                        if type(to) is GeneratorType:",
            "                            stk.append(to)",
            "                            to = next(to)",
            "                        else:",
            "                            stk.pop()",
            "                            if not stk:",
            "                                break",
            "                            to = stk[-1].send(to)",
            "                    return to",
            "            return wrappedfunc",
            "",
            "    if hashing:",
            "        RANDOM = random.getrandbits(20)",
            "        class Wrapper(int):",
            "            def __init__(self, x):",
            "                int.__init__(x)",
            "",
            "            def __hash__(self):",
            "                return super(Wrapper, self).__hash__() ^ RANDOM",
            "",
            "    if read_from_file:",
            "        file = open(\"input.txt\", \"r\").readline().strip()[1:-1]",
            "        fin = open(file, 'r')",
            "        input = lambda: fin.readline().strip()",
            "        output_file = open(\"output.txt\", \"w\")",
            "        def fprint(*args, **kwargs):",
            "            print(*args, **kwargs, file=output_file)",
            "",
            "    if de:",
            "        def debug(*args, **kwargs):",
            "            print('\\033[92m', end='')",
            "            print(*args, **kwargs)",
            "            print('\\033[0m', end='')",
            "",
            "    fmax = lambda x, y: x if x > y else y",
            "    fmin = lambda x, y: x if x < y else y",
            "",
            "    class lst_lst:",
            "        def __init__(self, n) -> None:",
            "            self.n = n",
            "            self.pre = []",
            "            self.cur = []",
            "            self.lst = [-1] * n",
            "        ",
            "        def append(self, i, j):",
            "            self.pre.append(self.lst[i])",
            "            self.lst[i] = len(self.cur)",
            "            self.cur.append(j)",
            "        ",
            "        def iterate(self, i):",
            "            tmp = self.lst[i]",
            "            while tmp != -1:",
            "                yield self.cur[tmp]",
            "                tmp = self.pre[tmp]"
        ],
        "description": "Snippet for pyMain in python",
        "scope": "python"
    },
    "singleCase": {
        "prefix": "singleCase",
        "body": [
            "#include <iostream>",
            "int t;",
            "void solve(){",
            "",
            "}",
            "signed main() ",
            "{",
            "    cin>>t;",
            "    solve();",
            "    return 0;",
            "}"
        ],
        "description": "Snippet for singleCase in cpp",
        "scope": "cpp"
    },
    "SPFA": {
        "prefix": "SPFA",
        "body": [
            "const int N = 10010;",
            "const int M = 2*N;",
            "int h[N],ne[M],e[M],w[M],idx;",
            "",
            "bitset<N> st;",
            "int dist[N];",
            "void init(){",
            "\tmemset(h,-1,sizeof h);",
            "\tidx= 0;",
            "}",
            "void add(int a , int b, int c){",
            "\te[idx] =b;",
            "\tw[idx] = c;",
            "\tne[idx] =h[a],h[a] = idx;",
            "\tidx++;",
            "}",
            "",
            "",
            "void spfa(int S,int E){",
            "\tmemset(dist,0x3f,sizeof dist);",
            "\tdist[S] = 0;",
            "\tqueue<int> q;",
            "\tq.push(S);",
            "\tst[S] = true;",
            "\twhile(q.size()){",
            "\t\tauto f = q.front();",
            "\t\tq.pop();",
            "\t\tst[f] = false;",
            "\t\tfor(int i = h[f];~i;i = ne[i]){",
            "\t\t\tint j = e[i];",
            "\t\t\tif(dist[j]> dist[f] + w[i]){",
            "\t\t\t\tif(!st[j])",
            "\t\t\t\t{",
            "\t\t\t\t\tdist[j]= dist[f] + w[i];",
            "\t\t\t\t\tq.push(j);",
            "\t\t\t\t\tst[j] = true;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "}"
        ],
        "description": "Snippet from SPFA",
        "scope": "cpp"
    },
    "Trie": {
        "prefix": "Trie",
        "body": [
            "int son[N][26], cnt[N], idx;",
            "",
            "void insert(char *str)",
            "{",
            "    int p = 0;",
            "    for (int i = 0; str[i]; i++)",
            "    {",
            "        int u = str[i] - 'a';",
            "        if (!son[p][u])",
            "            son[p][u] = ++idx;",
            "        p = son[p][u];",
            "    }",
            "    cnt[p]++; ",
            "}",
            "",
            "int query(char *str)",
            "{",
            "    int p = 0;",
            "    for (int i = 0; str[i]; i++)",
            "    {",
            "        int u = str[i] - 'a';",
            "        if (!son[p][u])",
            "            return 0;",
            "        p = son[p][u];",
            "    }",
            "    return cnt[p];",
            "}"
        ],
        "description": "Snippet from Trie",
        "scope": "cpp"
    },
    "Unbounded Knapsack": {
        "prefix": "Unbounded Knapsack",
        "body": [
            "//完全背包",
            "",
            "int complate_bp(int n,const vector<int> & w,const vector<int>&v, int V){",
            "    /*",
            "    w :weight",
            "    v :value",
            "    V :Capacity",
            "    */",
            "    vector<int> dp(V + 1, 0); // dp[i]表示容量为i时的最大价值",
            "    for (int i = 0; i < n; ++i) {",
            "        for (int j = w[i]; j <= V; ++j) {",
            "            dp[j] = max(dp[j], dp[j - w[i]] + v[i]);",
            "        }",
            "    }",
            "    return /*res */;",
            "}"
        ],
        "description": "Snippet for Unbounded Knapsack in cpp",
        "scope": "cpp"
    },
    "Union-Find": {
        "prefix": "Union-Find",
        "body": [
            "const int N = 10010;",
            "int p[N];",
            "",
            "void init(int n) {",
            "    for (int i = 1; i <= n; i++) p[i] = i;",
            "}",
            "",
            "int find(int x) {",
            "    return p[x] == x ? x : p[x] = find(p[x]);",
            "}",
            "",
            "void merge(int a, int b) {",
            "    p[find(a)] = find(b);",
            "}",
            "",
            "bool same(int a, int b) {",
            "    return find(a) == find(b);",
            "}"
        ],
        "description": "Snippet from Union-Find",
        "scope": "cpp"
    },
    "孙国庆的防检重标识": {
        "prefix": "孙国庆的防检重标识",
        "body": [
            "/*",
            "    Coded by: <SunGq>",
            "    团队Github: https://github.com/AliceAuto/AcEasy",
            "    Welcoming to join our team!",
            "*/",
            "/*",
            "     /\\_/\\  ",
            "    ( o.o ) ",
            "     > ^ <",
            "*/",
            "/*",
            "--------------------------------------------------------------------------------------------------------------------------------------------------------",
            "--------------------------------------------------------------------------------------------------------------------------------------------------------",
            "--------------------------------------------------------------------------------------------------------------------------------------------------------",
            "--------------------------------------------------------------------------------------------------------------------------------------------------------",
            "--------------------------------------------------------------------------------------------------------------------------------------------------------",
            "--------------------------------------------------------------------------------------------------------------------------------------------------------",
            "--------------------------------------------------------------------------------------------------------------------------------------------------------",
            "=-------------------------------------------------------------------------------------------------------------------------------------------------------",
            "-----------------------------------------------------------------------------------------------:--------------------------------------------------------",
            "--------------------------------------------------------------------------------------------------------------------------------------------------------",
            "--------------------------------------------------------------++*++++=+*++*+=---------------------------------------------------------------------------",
            "-----------------------------------------------------------+++-:::::::::==--=+++=-----------------------------------------------------------------------",
            "---------------------------------------------------------+*=:::::::::::::-+-----=++=--------------------------------------------------------------------",
            "------------------------------------------------------:=*=::::::::::::::::-+=-:::--++=-----------------=+=----------------------------------------------",
            "------------------------------------------------------+*-:::::::::::::::::::++-:::::=+=---------------=+*+----------------------------------------------",
            "-----------------------------------------------------+*-:::::::::::::::::::::+=::::::=+*+++==---------++++----------------------------------------------",
            "----------------------------------------------------=*=:::::::::::::::::::::::+=---:::=+++++++++==---=+++*+----------------------=====------------------",
            "----------------------------------------------------++::::::::::::::::::::::::-+-::--:-+=--+++==++*+==++=+++---------------======-----=++==-------------",
            "---------------------------------------------------=*-:::::::::::::::::::::::::=+---===++=---+*=====++++===**=----------=+=-:::---:::-::---+=-----------",
            "---------------------------------------------------++:::::::::::::::::::::-==++*++++++======+++*============+*+-------=+=-::--::::--:-:--::--=+---------",
            "---------------------------------------------------++:::::::::::::::::::::::-=++*+=====+=======+==============**=----==---::----:::-==+++++=--=+=-------",
            "---------------------------------------------------++:::::::::::::::::::::::=++--+===+*+=======================+**=-==:----:---::-+=::::::::::::==------",
            "---------------------------------------------------++::::::::::::---:::::++-:-:::-=+++==========++*++=====+++====+**+-::-:::--::=+:::::::::::::::-=-----",
            "---------------------------------------------------+*-:::::::::::=+-::-+=--::-::::-++==++=-=+===+--=+=-=+-::=+++===+*=:::::----==:::::::::::::::::==----",
            "----------------------------------------------------*-::::::::::::===+=-------:--:=+++-:::-:-**=+=-------:::-----++=+++-::::---+-::::::::::::::::::=----",
            "----------------------------------------------------++-:::::::::::-++---:----:-:-:-=-::---:::--+++---------:------:---=+=---::==::::::::::::::::::::+=--",
            "-----------------------------------------------------*+::::::::::-+=--+++=--:-:-::-:::::::::-:--------:--::::--:---::--=+=:-:-+-::::::::::::::::::::==--",
            "-----------------------------------------------------=*-::::::::=+=-:::::-:::::---::-::--:::-:-::::::--::-::----:--:-:-:=+-::=+-:::::::::::::::::::::+--",
            "------------------------------------------------------+*-::::::-+=-::-------:::::-::--::-::--:-::-::----::::-:-::::-::---==--==::::::::::::::::::::::=--",
            "-------------------------------------------------------++::::::==:::-:-:--:-:::--:---::::---:-:::+=--::::--:---:--::::-:--++-+-::::::::::::::::::::::==-",
            "--------------------------------------------------------+*-:::=+-:::---:-----:--:-----::-::---:-:-++-::::--:-::-:--:--::-:-=++-::::::::::::::::::::::-=-",
            "---------------------------------------------------------=*=::+=-::-:::--:-::-::-:--------::::-:::-=-::---------:::--:::::---=-::::::::::::::::::::::-+-",
            "-----------------------------------------------------------++=+-:::-------:--:-:-::::-::::---=-------::::---:---::--::::::----:::::::::::::::::::::::-+-",
            "------------------------------------------------------------=+=::-=+****+--:----::::::---=+*****+-----::::::-::-:::-:----:::--::::::::=::::::::::::::-+-",
            "-------------------------------------------------------------==::--+******=:---:----:::-+**##*****=-::::-::::-----:---:--:::--::::::++-::::::::::::::==-",
            "--------------------------------------=----------------------==--::-***##*+:-:---::-:--:=****##***+-:::::::::-:------:--:-----:::::=+::::::::::::::::=--",
            "-------------------------------------------------------------==--:::-*##*=-:::-:-:--:-::-******#*+:-::::---:::---:---:-::----=-==-::::::::::::::::::-+--",
            "--------------------------------------------+++=--------------+:-:::::::::-:----:-::--::::***##*:::-----:::--::-::-:-::-----=-::::::::::::::::::::::+=--",
            "-------------------------------------------=+===------------===--::::::::--==--------:::::::::::::-------::--::--::------::--::::::::::::::::::::::==---",
            "--------------------------------------------+===-----------+=-:-:::-::::::::::::::=---::::::::::::-:::-:::::--:::---::::::-=-:::::::::::::::::::::==----",
            "--------------------------------------------+++++=--------+-::::::-::::+*****+:::::::-::-===------::---------:::::------::-=-::::::::::::::::::::==-----",
            "--------------------------------------------===----------=+::::-:--::::+#*####+::::::-+=------:--::-:-----::--::::---:-::-=-:::::::::::::::::::-+=------",
            "-------------------==---------------------*++=------------+-----:--::::::===::::::::-=-:--------:::--::--:::-------------==:::::::::::::::::::=+--------",
            "--------------=+**+=---------------*+-----=++--------------+=--------:::::::::::::::-=::::--::--:--:-:-----:------------=+=++=::::::::::::-=+=----------",
            "---------=++**+*+--------------+=-=**=-----+=-------------+++++=--:------::::::::::::=--::------:-------:::----:::-:---+=----====++++++====-------------",
            "------=++++=---=*-------=---+++*+=*=**----=*-------------++++++++=----::--:::::::::::-==---::-::-:-::---::-:--::::-:-+=---------------------------------",
            "----------------*+=***+-+*+=**++**=-=*+::=*+------------=*+++++++++=--::---:::::::::--:---:::---:::----:-::--:--::==+-----------------------------------",
            "----------------++*+-+*-+*+-++--=----+*=**+-------------=*++++++++++++=-::--=::::==---::::--:-::-------:::------=+=-------------------------------------",
            "----------------*+**++==-+=----------=**+---------------+*+++++++***++++===++++++++++=------:--::----::::::--=+=----------------------------------------",
            "---------------=*+-=**-------------+****----------------=*++++++****++++*+++++++++++++++---:--:::-------==++--------------------------------------------",
            "---------------+*=--------------=**+=-**-----------------*++++++++++++++*+++++++++++++++---======++++==-------------------------------------------------",
            "----------==-=**---------------+*=----**-----------------=*++++++=-::-=++++++++++++++++=:::-+=----------------------------------------------------------",
            "------------==-------------=--=+=----+*=------------------+++++*=::::::=++++++++++++++=:-:-::*=---------------------------------------------------------",
            "------------------------=+=----=----=**--------------------=++=-:::::::=+++++++++++++=:::::-:=*---------------------------------------------------------",
            "----------=+=--------=*+=-==-------=**--------------------==:-=:::::::::+++++++++++=-::-:::-::++--------------------------------------------------------",
            "---------=+-=----=**+=-----+=----+**+---------------------+--=-::::::::::=+++++==+=--------:-:-*=-------------------------------------------------------",
            "----------=++++++=----------=+***+=----------------------=+::=-:::::::::::::::-=-==---:::-::::-++-------------------------------------------------------",
            "----------++=--------------------------------------------+=:-=-:::::::::::::::::-+=:--::-:--:-:=*-------------------------------------------------------",
            "---------------------------------------------------------=+--==::::::::::::::::::=+---:::::---:-*=------------------------------------------------------",
            "---------------------------------------------------------=+-:-=:::::::::::::::::::=--------:-::-+-==----------------------------------------------------",
            "----------------------------------------------------------+-:-==::::::::::::::::::-=-----:-:::::+-:-==--------------------------------------------------",
            "----------------------------------------------------------++-:-=-:::::::::::::::::-----:----:---=:---=+=------------------------------------------------",
            "-----------------------------------------------------------+=-:-=-:::::::::::::::-::::::::::::::-:-::--+=-----------------------------------------------",
            "------------------------------------------------------------+=:--=-::::::::::::::-::::::::::::::=--::---+=----------------------------------------------",
            "-------------------------------------------------------------+=-----:::::::::::::::::::::::::::::=:::---++----------------------------------------------",
            "--------------------------------------------------------------==::::-::::::::::::::::::::::::::::=::---:=+=---------------------------------------------",
            "----------------------------------------------------------------==-::-:::::::::::::::::::::::::=+-:::---=+=---------------------------------------------",
            "--------------------------------------------------------------------==+-:::::::::::::::--::--::=::--::--==----------------------------------------------",
            "------------------------------------------------------------------------=::::::::::::::::::::::=:-:::::-==----------------------------------------------",
            "--------------------------------------------------------------------------=-:::::::::::::::::::=--:-:--==-----------------------------------------------",
            "-----------------------------------------------------------------------------=::::::::::::::::=:-:::---=------------------------------------------------",
            "-------------------------------------------------------------------------------==-:::::::::::---:-----====+==-------------------------------------------",
            "----------------------------------------------------------------------------------====--:-----:-:----==++=----------------------------------------------",
            "----------------------------------------------------------------------------------------======++++=====-------------------------------------------------",
            "--------------------------------------------------------------------------------------------------------------------------------------------------------",
            "--------------------------------------------------------------------------------------------------------------------------------------------------------",
            "*/"
        ],
        "description": "Snippet for 孙国庆的防检重标识 in cpp",
        "scope": "cpp"
    }
}