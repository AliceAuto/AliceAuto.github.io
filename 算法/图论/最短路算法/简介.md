# 最短路问题

**源点就是起点，汇点就是终点，n表示节点数，m表示边数**

![alt text](1833_db6dffa81d-37ff39642fd8f74476ddcd99944d1b4.png)




## 文字性复习

### Dijkstra-朴素O(n^2)

初始化距离数组:
- `dist[1] = 0`
- `dist[i] = inf`

进行n次循环，每次循环确定一个最小值加入S集合，n次之后得出所有的最短距离：
1. 将不在S中`dist_min`的点设为`t`
2. 将`t`加入S集合，并加入最短路集合
3. 用`t`更新到其他点的距离

### Dijkstra-堆优化O(mlogm)

利用邻接表和优先队列：
- 在`priority_queue<, greater<> > heap;`中将返回堆顶
- 利用堆顶来更新其他点，并加入堆中，类似宽搜

### Bellman_fordO(nm)

注意连锁想象需要备份:
- `struct Edge { int a, b, c; } Edge[M];`
- 初始化`dist`
- 松弛：`dist[x.b] = min(dist[x.b], backup[x.a] + x.w)`
- 进行k次松弛，每次访问m条边

### Spfa O(n)~O(nm)

利用队列优化，仅加入修改过的地方：
1. 进行k次循环
2. 利用宽搜模型去优化bellman_ford算法
3. 更新队列中当前点的所有出边

### Floyd O(n^3)

初始化`d`，然后利用`k, i, j`去更新`d`。


---


| 算法名称             | 适用场景                          | 时间复杂度             | 空间复杂度             | 处理负权边 | 检测负权环 |
| -------------------- | --------------------------------- | ---------------------- | ---------------------- | ---------- | ---------- |
| **Floyd-Warshall**   | 计算所有节点对之间的最短路径      | O(n³)                 | O(n²)                 | ✅         | ✅         |
| **Bellman-Ford**     | 单源最短路径（可处理负权边）      | O(VE)                 | O(V + E)             | ✅         | ✅         |
| **SPFA**            | 单源最短路径（可处理负权边，但无负权环） | 平均O(E/V)，最坏O(VE) | O(V + E)             | ✅         | ❌         |
| **Dijkstra**        | 单源最短路径（无负权边）          | O((V + E) log V)      | O(V + E)             | ❌         | ❌         |
| **A\***             | 启发式搜索，适用于有启发式信息的图 | 取决于启发式函数的质量 | O(V)                 | ❌         | ❌         |

**总结：**

- **Floyd-Warshall算法**：适用于计算所有节点对之间的最短路径，能够处理负权边并检测负权环，但时间复杂度较高，适合规模较小的图。

- **Bellman-Ford算法**：适用于单源最短路径问题，能够处理负权边并检测负权环，但在大型图中效率较低。

- **SPFA算法**：在平均情况下优于Bellman-Ford，但在最坏情况下可能退化为O(VE)。适用于带有负权边的图。

- **Dijkstra算法**：适用于无负权边的图，效率高，特别是在稀疏图中。

- **A*算法**：在具有有效启发式信息的情况下表现优异，但需要设计有效的启发式函数。

因此，选择最合适的算法应根据图的特性和具体需求来决定。 